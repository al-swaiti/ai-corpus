[
  {
    "url": "https://modelcontextprotocol.io/docs",
    "content": "MCP is an open protocol that standardizes how applications provide context to large language models (LLMs). Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP provides a standardized way to connect AI models to different data sources and tools. MCP enables you build agents and complex workflows on top of LLMs and connects your models with the world.MCP provides:\n\nA growing list of pre-built integrations that your LLM can directly plug into\n\nA standardized way to build custom integrations for AI applications\n\nAn open protocol that everyone is free to implement and use\n\nThe flexibility to change between different apps and take your context with you\n\nMCP provides official SDKs in multiple languages, see the SDK documentation to find the right SDK for your project. The SDKs handle the protocol details so you can focus on building your features.",
    "metadata": {
      "title": "Introduction - Model Context Protocol",
      "description": "Get started with the Model Context Protocol (MCP)",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs",
      "extracted_at": "2025-08-04T09:54:24.349044+00:00"
    },
    "word_count": 157,
    "char_count": 963,
    "crawl_depth": 0,
    "crawled_at": "2025-08-04T09:54:24.349071+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/getting-started/intro",
    "content": "MCP is an open protocol that standardizes how applications provide context to large language models (LLMs). Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP provides a standardized way to connect AI models to different data sources and tools. MCP enables you build agents and complex workflows on top of LLMs and connects your models with the world.MCP provides:\n\nA growing list of pre-built integrations that your LLM can directly plug into\n\nA standardized way to build custom integrations for AI applications\n\nAn open protocol that everyone is free to implement and use\n\nThe flexibility to change between different apps and take your context with you\n\nMCP provides official SDKs in multiple languages, see the SDK documentation to find the right SDK for your project. The SDKs handle the protocol details so you can focus on building your features.",
    "metadata": {
      "title": "Introduction - Model Context Protocol",
      "description": "Get started with the Model Context Protocol (MCP)",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/getting-started/intro",
      "extracted_at": "2025-08-04T09:54:25.550825+00:00"
    },
    "word_count": 157,
    "char_count": 963,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:25.550846+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/overview",
    "content": "AI-enabled tools are powerful, but they’re often limited to the information you manually provide or require bespoke integrations.\n\nWhether it’s reading files from your computer, searching through an\ninternal or external knowledge base, or updating tasks in an project\nmanagement tool, MCP provides a secure, standardized, *simple* way\nto give AI systems the context they need.\n\nPick from pre-built servers for popular tools like GitHub, Google Drive, Slack and hundreds of others. Combine multiple servers for complete workflows, or easily build your own for custom integrations.\n\nConfigure your AI application (like Claude, VS Code, or ChatGPT) to connect to your MCP servers. The application can now see available tools, resources and prompts from all connected servers.\n\nYour AI-powered application can now access real data, execute actions, and provide more helpful responses based on your actual context.",
    "metadata": {
      "title": "Model Context Protocol - Model Context Protocol",
      "description": "The open protocol that connects AI applications to the systems where context lives",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/overview",
      "extracted_at": "2025-08-04T09:54:26.784454+00:00"
    },
    "word_count": 136,
    "char_count": 909,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:26.784474+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/tutorials/use-remote-mcp-server",
    "content": "Navigate to Connector Settings\n\nOpen Claude in your browser and navigate to the settings page. You can access this by clicking on your profile icon and selecting “Settings” from the dropdown menu. Once in settings, locate and click on the “Connectors” section in the sidebar.This will display your currently configured connectors and provide options to add new ones.",
    "metadata": {
      "title": "Connect to Remote MCP Servers - Model Context Protocol",
      "description": "Learn how to connect Claude to remote MCP servers and extend its capabilities with internet-hosted tools and data sources",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/tutorials/use-remote-mcp-server",
      "extracted_at": "2025-08-04T09:54:27.990012+00:00"
    },
    "word_count": 58,
    "char_count": 366,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:27.990024+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/quickstart/server",
    "content": "`get_alerts`\n\nand `get_forecast`\n\n. Then we’ll connect the server to an MCP host (in this case, Claude for Desktop):\n`print()`\n\nstatements in Python`console.log()`\n\nin JavaScript`fmt.Println()`\n\nin Go`uv`\n\nand set up our Python project and environment:`uv`\n\ncommand gets picked up.Now, let’s create and set up our project:`weather.py`\n\n:`uv run weather.py`\n\nto start the MCP server, which will listen for messages from MCP hosts.Let’s now test your server from an existing MCP host, Claude for Desktop.`~/Library/Application Support/Claude/claude_desktop_config.json`\n\nin a text editor. Make sure to create the file if it doesn’t exist.For example, if you have VS Code installed:`mcpServers`\n\nkey. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.In this case, we’ll add our single weather server like so:`uv`\n\nexecutable in the `command`\n\nfield. You can get this by running `which uv`\n\non MacOS/Linux or `where uv`\n\non Windows.`pwd`\n\non MacOS/Linux or `cd`\n\non Windows Command Prompt. On Windows, remember to use double backslashes (`\\\\`\n\n) or forward slashes (`/`\n\n) in the JSON path.`uv --directory /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather run weather.py`\n\n`weather`\n\nserver. You can do this by looking for the “Search and tools” icon:\nClaude for Desktop Integration Issues\n\n`~/Library/Logs/Claude`\n\n:`mcp.log`\n\nwill contain general logging about MCP connections and connection failures.`mcp-server-SERVERNAME.log`\n\nwill contain error (stderr) logging from the named server.`claude_desktop_config.json`\n\nfile syntaxWeather API Issues",
    "metadata": {
      "title": "Build an MCP Server - Model Context Protocol",
      "description": "Get started building your own server to use in Claude for Desktop and other clients.",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/quickstart/server",
      "extracted_at": "2025-08-04T09:54:29.439208+00:00"
    },
    "word_count": 221,
    "char_count": 1592,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:29.439236+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/versioning",
    "content": "The Model Context Protocol uses string-based version identifiers following the format\n`YYYY-MM-DD`\n\n, to indicate the last date backwards incompatible changes were made.\nThe protocol version will *not* be incremented when the\nprotocol is updated, as long as the changes maintain backwards compatibility. This allows\nfor incremental improvements while preserving interoperability.\n\n## Revisions\n\nRevisions may be marked as:\n**Draft**: in-progress specifications, not yet ready for consumption.\n**Current**: the current protocol version, which is ready for use and may continue to\nreceive backwards compatible changes.\n**Final**: past, complete specifications that will not be changed.\n\nThe **current** protocol version is **2025-06-18**.\n## Negotiation\n\nVersion negotiation happens during\ninitialization. Clients and\nservers **MAY** support multiple protocol versions simultaneously, but they **MUST**\nagree on a single version to use for the session.\nThe protocol provides appropriate error handling if version negotiation fails, allowing\nclients to gracefully terminate connections when they cannot find a version compatible\nwith the server.",
    "metadata": {
      "title": "Versioning - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/versioning",
      "extracted_at": "2025-08-04T09:54:30.951735+00:00"
    },
    "word_count": 154,
    "char_count": 1142,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:30.951749+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/learn/client-concepts",
    "content": "MCP clients are instantiated by host applications to communicate with particular MCP servers. The host application, like Claude.ai or an IDE, manages the overall user experience and coordinates multiple clients. Each client handles one direct communication with one server.\nUnderstanding the distinction is important: the *host* is the application users interact with, while *clients* are the protocol-level components that enable server connections.\n## Core Client Features\n\nIn addition to making use of context provided by servers, clients may provide several features to servers. These client features allow server authors to build richer interactions. For example, clients can allow MCP servers to request additional information from the user via elicitations. Clients can offer the following capabilities:\n### Sampling\n\nSampling allows servers to request language model completions through the client, enabling agentic behaviors while maintaining security and user control.\n#### Overview\n\nSampling enables servers to perform AI-dependent tasks without directly integrating with or paying for AI models. Instead, servers can request that the client—which already has AI model access—handle these tasks on their behalf. This approach puts the client in complete control of user permissions and security measures. Because sampling requests occur within the context of other operations—like a tool analyzing data—and are processed as separate model calls, they maintain clear boundaries between different contexts, allowing for more efficient use of the context window.\n**Sampling flow:**\nThe flow ensures security through multiple human-in-the-loop checkpoints. Users review and can modify both the initial request and the generated response before it returns to the server.\n**Request parameters example:**\nConsider a travel booking server with a tool called `findBestFlight`\n\nthat uses sampling to analyze available flights and recommend the optimal choice. When a user asks “Book me the best flight to Barcelona next month,” the tool needs AI assistance to evaluate complex trade-offs.\nThe tool queries airline APIs and gathers 47 flight options. It then requests AI assistance to analyze these options: “Analyze these flight options and recommend the best choice: [47 flights with prices, times, airlines, and layovers] User preferences: morning departure, max 1 layover.”\nThe client asks the user: “Allow sampling request?” Upon approval, the AI evaluates trade-offs—like cheaper red-eye flights versus convenient morning departures. The tool uses this analysis to present the top three recommendations.\n#### User Interaction Model\n\nSampling is designed with human-in-the-loop control as a fundamental principle. Users maintain oversight through several mechanisms:\n**Approval controls**: Every sampling request needs explicit user consent. Clients show what the server wants to analyze and why. Users can approve, deny, or modify requests.\n**Transparency features**: Clients display the exact prompt, model selection, and token limits. Users review AI responses before they return to the server.\n**Configuration options**: Users can set model preferences, configure auto-approval for trusted operations, or require approval for everything. Clients may provide options to redact sensitive information. Users decide how much conversation context may be included in sampling requests through the `includeContext`\n\nparameter.\n**Isolation**: Sampling requests are isolated from the main conversation context by default. Servers cannot access user conversations.\n**Security considerations**: Both clients and servers must handle sensitive data appropriately during sampling. Clients should implement rate limiting and validate all message content. The human-in-the-loop design ensures that server-initiated AI interactions cannot compromise security or access sensitive data without explicit user consent.\n### Roots\n\nRoots define filesystem boundaries for server operations, allowing clients to specify which directories servers should focus on.\n#### Overview\n\nRoots are a mechanism for clients to communicate filesystem access boundaries to servers. They consist of file URIs that indicate directories where servers can operate, helping servers understand the scope of available files and folders. Rather than giving servers unrestricted filesystem access, roots guide them to relevant working directories while maintaining security boundaries.\n**Root structure:**\nRoots are exclusively filesystem paths and always use the `file://`\n\nURI scheme. They help servers understand project boundaries, workspace organization, and accessible directories. The roots list can be updated dynamically as users work with different projects or folders, with servers receiving notifications through `roots/list_changed`\n\nwhen boundaries change.\nIt’s important to note that while roots provide guidance to servers about where to operate, the client is always in full control of file access. Roots simply communicate intended boundaries—actual file access is always mediated by the client’s security policies.\n#### Example: Travel Planning Workspace\n\nA travel agent working with multiple client trips benefits from roots to organize filesystem access. Consider a workspace with different directories for various aspects of travel planning.\nThe client provides filesystem roots to the travel planning server:\n`file:///Users/agent/travel-planning`\n\n- Main workspace containing all travel files\n`file:///Users/agent/travel-templates`\n\n- Reusable itinerary templates and resources\n`file:///Users/agent/client-documents`\n\n- Client passports and travel documents\n\nWhen the agent creates a Barcelona itinerary, the server works within these boundaries—accessing templates, saving the new itinerary, and referencing client documents. It cannot access files outside these roots. Servers typically access files within roots by using relative paths from the root directories or by utilizing file search tools that respect the root boundaries.\nIf the agent opens an archive folder like `file:///Users/agent/archive/2023-trips`\n\n, the client updates the roots list via `roots/list_changed`\n\n.\n#### User Interaction Model\n\nRoots are typically managed automatically by host applications based on user actions, though some applications may expose manual root management:\n**Automatic root detection**: When users open folders, clients automatically expose them as roots. Opening a travel workspace gives servers access to itineraries and documents within that directory.\n**Manual root configuration**: Advanced users can specify roots through configuration. For example, adding `/travel-templates`\n\nfor reusable resources while excluding directories with financial records.\n### Elicitation\n\nElicitation enables servers to request specific information from users during interactions, creating more dynamic and responsive workflows.\n#### Overview\n\nElicitation provides a structured way for servers to gather necessary information on demand. Instead of requiring all information up front or failing when data is missing, servers can pause their operations to request specific inputs from users. This creates more flexible interactions where servers adapt to user needs rather than following rigid patterns.\n**Elicitation flow:**\nThe flow enables dynamic information gathering. Servers can request specific data when needed, users provide information through appropriate UI, and servers continue processing with the newly acquired context.\n**Elicitation components example:**\n#### Example: Holiday Booking Approval\n\nA travel booking server demonstrates elicitation’s power through the final booking confirmation process. When a user has selected their ideal vacation package to Barcelona, the server needs to gather final approval and any missing details before proceeding.\nThe server elicits booking confirmation with a structured request that includes the trip summary (Barcelona flights June 15-22, beachfront hotel, total $3,000) and fields for any additional preferences—such as seat selection, room type, or travel insurance options.\nAs the booking progresses, the server elicits contact information needed to complete the reservation. It might ask for traveler details for flight bookings, special requests for the hotel, or emergency contact information.\n#### User Interaction Model\n\nElicitation interactions are designed to be clear, contextual, and respectful of user autonomy:\n**Request presentation**: Clients display elicitation requests with clear context about which server is asking, why the information is needed, and how it will be used. The request message explains the purpose while the schema provides structure and validation.\n**Response options**: Users can provide the requested information through appropriate UI controls (text fields, dropdowns, checkboxes), decline to provide information with optional explanation, or cancel the entire operation. Clients validate responses against the provided schema before returning them to servers.\n**Privacy considerations**: Elicitation never requests passwords or API keys. Clients warn about suspicious requests and let users review data before sending.",
    "metadata": {
      "title": "Client Concepts - Model Context Protocol",
      "description": "Understanding MCP client concepts",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/learn/client-concepts",
      "extracted_at": "2025-08-04T09:54:32.436009+00:00"
    },
    "word_count": 1249,
    "char_count": 9186,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:32.436096+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/quickstart/client",
    "content": "`uv`\n\ninstalled`uv`\n\n:`.env`\n\nfile to store it:`.env`\n\nfile:`.env`\n\nto your `.gitignore`\n\n:`ANTHROPIC_API_KEY`\n\nsecure!`client.py`\n\nfile here.`MCPClient`\n\nclass initializes with session management and API clients`AsyncExitStack`\n\nfor proper resource management`process_query()`\n\nto handle specific tool types`python client.py .../quickstart-resources/weather-server-python/weather.py`\n\n`AsyncExitStack`\n\nfor proper cleanup`.env`\n\n`FileNotFoundError`\n\n: Check your server path`Connection refused`\n\n: Ensure the server is running and the path is correct`Tool execution failed`\n\n: Verify the tool’s required environment variables are set`Timeout error`\n\n: Consider increasing the timeout in your client configuration",
    "metadata": {
      "title": "Build an MCP Client - Model Context Protocol",
      "description": "Get started building your own client that can integrate with all MCP servers.",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/quickstart/client",
      "extracted_at": "2025-08-04T09:54:33.931446+00:00"
    },
    "word_count": 77,
    "char_count": 713,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:33.931466+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/sdk",
    "content": "Official SDKs for building with the Model Context Protocol\n\nBuild MCP servers and clients using our official SDKs. Choose the SDK that matches your technology stack - all SDKs provide the same core functionality and full protocol support.",
    "metadata": {
      "title": "SDKs - Model Context Protocol",
      "description": "Official SDKs for building with the Model Context Protocol",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/sdk",
      "extracted_at": "2025-08-04T09:54:35.147745+00:00"
    },
    "word_count": 38,
    "char_count": 238,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:35.147756+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/learn/architecture",
    "content": "`*/list`\n\n), retrieval (`*/get`\n\n), and in some cases, execution (`tools/call`\n\n).\nMCP clients will use the `*/list`\n\nmethods to discover available primitives. For example, a client can first list all available tools (`tools/list`\n\n) and then execute them. This design allows listings to be dynamic.\nAs a concrete example, consider an MCP server that provides context about a database. It can expose tools for querying the database, a resource that contains the schema of the database, and a prompt that includes few-shot examples for interacting with the tools.\nFor more details about server primitives see server concepts.\nMCP also defines primitives that `sampling/complete`\n\nmethod to request a language model completion from the client’s AI application.`elicitation/request`\n\nmethod to request additional information from the user.Initialization (Lifecycle Management)\n\n`initialize`\n\nrequest to establish the connection and negotiate supported features.`protocolVersion`\n\nfield (e.g., “2025-06-18”) ensures both client and server are using compatible protocol versions. This prevents communication errors that could occur when different versions attempt to interact. If a mutually compatible version is not negotiated, the connection should be terminated.\n`capabilities`\n\nobject allows each party to declare what features they support, including which primitives they can handle (tools, resources, prompts) and whether they support features like notifications. This enables efficient communication by avoiding unsupported operations.\n`clientInfo`\n\nand `serverInfo`\n\nobjects provide identification and versioning information for debugging and compatibility purposes.\n`\"tools\": {}`\n\n- The client declares it can work with the tools primitive (can call `tools/list`\n\nand `tools/call`\n\nmethods)`\"tools\": {\"listChanged\": true}`\n\n- The server supports the tools primitive AND can send `tools/list_changed`\n\nnotifications when its tool list changes`\"resources\": {}`\n\n- The server also supports the resources primitive (can handle `resources/list`\n\nand `resources/read`\n\nmethods)Tool Discovery (Primitives)\n\n`tools/list`\n\nrequest. This request is fundamental to MCP’s tool discovery mechanism — it allows clients to understand what tool are available on the server before attempting to use them.`tools/list`\n\nrequest is simple, containing no parameters.`tools`\n\narray that provides comprehensive metadata about each available tool. This array-based structure allows servers to expose multiple tools simultaneously while maintaining clear boundaries between different functionalities.Each tool object in the response includes several key fields:`name`\n\n`com.example.calculator/arithmetic`\n\nrather than just `calculate`\n\n)`title`\n\n`description`\n\n`inputSchema`\n\nTool Execution (Primitives)\n\n`tools/call`\n\nmethod. This demonstrates how MCP primitives are used in practice: after discovering available tools, the client can invoke them with appropriate arguments.`tools/call`\n\nrequest follows a structured format that ensures type safety and clear communication between client and server. Note that we’re using the proper tool name from the discovery response (`com.example.weather/current`\n\n) rather than a simplified name:`name`\n\n`com.example.weather/current`\n\n). This ensures the server can correctly identify which tool to execute.\n`arguments`\n\n`inputSchema`\n\n. In this example:\n`location`\n\n: “San Francisco” (required parameter)`units`\n\n: “imperial” (optional parameter, defaults to “metric” if not specified)`id`\n\nfor request-response correlation.\n`content`\n\nArray`type`\n\nfield. In this example, `\"type\": \"text\"`\n\nindicates plain text content, but MCP supports various content types for different use cases.\nReal-time Updates (Notifications)\n\n`id`\n\nfield in the notification. This follows JSON-RPC 2.0 notification semantics where no response is expected or sent.\n`\"listChanged\": true`\n\nin their tools capability during initialization (as shown in Step 1).",
    "metadata": {
      "title": "Architecture Overview - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/learn/architecture",
      "extracted_at": "2025-08-04T09:54:36.516814+00:00"
    },
    "word_count": 512,
    "char_count": 3954,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:36.516856+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/",
    "content": "AI-enabled tools are powerful, but they’re often limited to the information you manually provide or require bespoke integrations.\n\nWhether it’s reading files from your computer, searching through an\ninternal or external knowledge base, or updating tasks in an project\nmanagement tool, MCP provides a secure, standardized, *simple* way\nto give AI systems the context they need.\n\nPick from pre-built servers for popular tools like GitHub, Google Drive, Slack and hundreds of others. Combine multiple servers for complete workflows, or easily build your own for custom integrations.\n\nConfigure your AI application (like Claude, VS Code, or ChatGPT) to connect to your MCP servers. The application can now see available tools, resources and prompts from all connected servers.\n\nYour AI-powered application can now access real data, execute actions, and provide more helpful responses based on your actual context.",
    "metadata": {
      "title": "Model Context Protocol - Model Context Protocol",
      "description": "The open protocol that connects AI applications to the systems where context lives",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/",
      "extracted_at": "2025-08-04T09:54:38.053750+00:00"
    },
    "word_count": 136,
    "char_count": 909,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:38.053769+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18",
    "content": "Model Context Protocol (MCP) is an open protocol that\nenables seamless integration between LLM applications and external data sources and\ntools. Whether you’re building an AI-powered IDE, enhancing a chat interface, or creating\ncustom AI workflows, MCP provides a standardized way to connect LLMs with the context\nthey need.\nThis specification defines the authoritative protocol requirements, based on the\nTypeScript schema in\nschema.ts.\nFor implementation guides and examples, visit\nmodelcontextprotocol.io.\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD\nNOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be\ninterpreted as described in BCP 14\n[RFC2119]\n[RFC8174] when, and only when, they\nappear in all capitals, as shown here.\n## Overview\n\nMCP provides a standardized way for applications to:\n- Share contextual information with language models\n- Expose tools and capabilities to AI systems\n- Build composable integrations and workflows\n\nThe protocol uses JSON-RPC 2.0 messages to establish\ncommunication between:\n**Hosts**: LLM applications that initiate connections\n**Clients**: Connectors within the host application\n**Servers**: Services that provide context and capabilities\n\nMCP takes some inspiration from the\nLanguage Server Protocol, which\nstandardizes how to add support for programming languages across a whole ecosystem of\ndevelopment tools. In a similar way, MCP standardizes how to integrate additional context\nand tools into the ecosystem of AI applications.\n## Key Details\n\n### Base Protocol\n\n- JSON-RPC message format\n- Stateful connections\n- Server and client capability negotiation\n\n### Features\n\nServers offer any of the following features to clients:\n**Resources**: Context and data, for the user or the AI model to use\n**Prompts**: Templated messages and workflows for users\n**Tools**: Functions for the AI model to execute\n\nClients may offer the following features to servers:\n**Sampling**: Server-initiated agentic behaviors and recursive LLM interactions\n**Roots**: Server-initiated inquiries into uri or filesystem boundaries to operate in\n**Elicitation**: Server-initiated requests for additional information from users\n\n### Additional Utilities\n\n- Configuration\n- Progress tracking\n- Cancellation\n- Error reporting\n- Logging\n\n## Security and Trust & Safety\n\nThe Model Context Protocol enables powerful capabilities through arbitrary data access\nand code execution paths. With this power comes important security and trust\nconsiderations that all implementors must carefully address.\n### Key Principles\n\n-\n**User Consent and Control**\n- Users must explicitly consent to and understand all data access and operations\n- Users must retain control over what data is shared and what actions are taken\n- Implementors should provide clear UIs for reviewing and authorizing activities\n\n-\n**Data Privacy**\n- Hosts must obtain explicit user consent before exposing user data to servers\n- Hosts must not transmit resource data elsewhere without user consent\n- User data should be protected with appropriate access controls\n\n-\n**Tool Safety**\n- Tools represent arbitrary code execution and must be treated with appropriate\ncaution.\n- In particular, descriptions of tool behavior such as annotations should be\nconsidered untrusted, unless obtained from a trusted server.\n\n- Hosts must obtain explicit user consent before invoking any tool\n- Users should understand what each tool does before authorizing its use\n\n-\n**LLM Sampling Controls**\n- Users must explicitly approve any LLM sampling requests\n- Users should control:\n- Whether sampling occurs at all\n- The actual prompt that will be sent\n- What results the server can see\n\n- The protocol intentionally limits server visibility into prompts\n\n\n### Implementation Guidelines\n\nWhile MCP itself cannot enforce these security principles at the protocol level,\nimplementors **SHOULD**:\n- Build robust consent and authorization flows into their applications\n- Provide clear documentation of security implications\n- Implement appropriate access controls and data protections\n- Follow security best practices in their integrations\n- Consider privacy implications in their feature designs\n\n## Learn More\n\nExplore the detailed specification for each protocol component:",
    "metadata": {
      "title": "Specification - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18",
      "extracted_at": "2025-08-04T09:54:39.264559+00:00"
    },
    "word_count": 622,
    "char_count": 4304,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:39.264605+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/community/governance",
    "content": "The Model Context Protocol (MCP) follows a formal governance model to ensure transparent decision-making and community participation. This document outlines how the project is organized and how decisions are made.\n## Technical Governance\n\nThe MCP project adopts a hierarchical structure, similar to Python, PyTorch and other open source projects:\n- A community of\n**contributors** who file issues, make pull requests, and contribute to the project.\n- A small set of\n**maintainers** drive components within the MCP project, such as SDKs, documentation, and others.\n- Contributors and maintainers are overseen by\n**core maintainers**, who drive the overall project direction.\n- The core maintainers have two\n**lead core maintainers** who are the catch-all decision makers.\n- Maintainers, core maintainers, and lead core maintainers form the\n**MCP steering group**.\n\nAll maintainers are expected to have a strong bias towards MCP’s design philosophy. Membership in the technical governance process is for individuals, not companies. That is, there are no seats reserved for specific companies, and membership is associated with the person rather than the company employing that person. This ensures that maintainers act in the best interests of the protocol itself and the open source community.\n### Channels\n\nTechnical Governance is facilitated through a shared Discord server of all **maintainers, core maintainers** and **lead maintainers**. Each maintainer group can choose additional communication channels, but all decisions and their supporting discussions must be recorded and made transparently available on the core group Discord server.\n### Maintainers\n\nMaintainers are responsible for individual projects or technical working groups within the MCP project. These generally are independent repositories such as language-specific SDKs, but can also extend to subdirectories of a repository, such as the MCP documentation. Maintainers may adopt their own rules and procedures for making decisions. Maintainers are expected to make decisions for their respective projects independently, but can defer or escalate to the core maintainers when needed.\nMaintainers are responsible for the:\n- Thoughtful and productive engagement with community contributors,\n- Maintaining and improving their respective area of the MCP project,\n- Supporting documentation, roadmaps and other adjacent parts of the MCP project,\n- Present ideas from community to core.\n\nMaintainers are encouraged to propose additional maintainers when needed. Maintainers can only be appointed and removed by core maintainers or lead core maintainers at any time and without reason.\nMaintainers have write and/or admin access to their respective repositories.\n### Core Maintainers\n\nThe core maintainers are expected to have a deep understanding of the Model Context Protocol and its specification. Their responsibilities include:\n- Designing, reviewing and steering the evolution of the MCP specification, as well as all other parts of the MCP project, such as documentation,\n- Articulating a cohesive long-term vision for the project,\n- Mediating and resolving contentious issues with fairness and transparency, seeking consensus where possible while making decisive choices when necessary,\n- Appoint or remove maintainers,\n- Stewardship of the MCP project in the best interest of MCP.\n\nThe core maintainers as a group have the power to veto any decisions made by maintainers by majority vote. The core maintainers have power to resolve disputes as they see fit. The core maintainers should publicly articulate their decision-making. The core group is responsible for adopting their own procedures for making decisions.\nCore maintainers generally have write and admin access to all MCP repositories, but should use the same contribution (usually pull-requests) mechanism as outside contributors. Exceptions can be made based on security considerations.\n### Lead Maintainers (BDFL)\n\nMCP has two lead maintainers: Justin Spahr-Summers and David Soria Parra. Lead Maintainers can veto any decision by core maintainers or maintainers. This model is also commonly known as Benevolent Dictator for Life (BDFL) in the open source community. The Lead Maintainers should publicly articulate their decision-making and give clear reasoning for their decisions. Lead maintainers are part of the core maintainer group.\nThe Lead Maintainers are responsible for confirming or removing core maintainers.\nLead Maintainers are administrators on all infrastructure for the MCP project where possible. This includes but is not restricted to all communication channels, GitHub organizations and repositories.\n### Decision Process\n\nThe core maintainer group meets every two weeks to discuss and vote on proposals, as well as discuss any topics needed. The shared Discord server can be used to discuss and vote on smaller proposals if needed.\nThe lead maintainer, core maintainer, and maintainer group should attempt to meet in person every three to six months.\n## Processes\n\nCore and lead maintainers are responsible for all aspects of Model Context Protocol, including documentation, issues, suggestions for content, and all other parts under the MCP project. Maintainers are responsible for documentation, issues, and suggestions of content for their area of the MCP project, but are encouraged to partake in general maintenance of the MCP projects. Maintainers, core maintainers, and lead maintainers should use the same contribution process as external contributors, rather than making direct changes to repos. This provides insight into intent and opportunity for discussion.\n### Projects and Working Groups\n\nThe MCP project is organized into two main structures: projects and working groups.\nProjects are concrete components maintained in dedicated repositories. These include the Specification, TypeScript SDK, Go SDK, Inspector, and other implementation artifacts.\nWorking groups are forums for collaboration where interested parties discuss specific aspects of MCP without maintaining code repositories. These include groups focused on transport protocols, client implementation, and other cross-cutting concerns.\n#### Governance Principles\n\nAll projects and working groups are self-governed while adhering to these core principles:\n- Clear contribution and decision-making processes\n- Open communication and transparent decisions\n\nBoth must:\n- Document their contribution process\n- Maintain transparent communication\n- Make decisions publicly (working groups must publish meeting notes and proposals)\n\nProjects and working groups without specified processes default to:\n- GitHub pull requests and issues for contributions\n- A public channel in the official MCP Discord (TBD)\n\n#### Maintenance Responsibilities\n\nComponents without dedicated maintainers (such as documentation) fall under core maintainer responsibility. These follow standard contribution guidelines through pull requests, with maintainers handling reviews and escalating to core maintainer review for any significant changes.\nCore maintainers and maintainers are encouraged to improve any part of the MCP project, regardless of formal maintenance assignments.\n### Specification Project\n\n#### Specification Enhancement Proposal (SEP)\n\nProposed changes to the specification must come in the form of a written version, starting with a summary of the proposal, outlining the **problem** it tries to solve, propose **solution**, **alternatives**, **considerations, outcomes** and **risks**. The SEP Guidelines outline information on the expected structure of SEPs. SEP’s should be created as issues in the specification repository and tagged with the labels `proposal, sep`\n\n.\nAll proposals must have a **sponsor** from the MCP steering group (maintainer, core maintainer or lead core maintainer). The sponsor is responsible for ensuring that the proposal is actively developed, meets the quality standard for proposals and is responsible for presenting and discussing it in meetings of core maintainers. Maintainer and Core Maintainer groups should review open proposals without sponsors in regular intervals. Proposals that do not find a sponsor within six months are automatically rejected.\nOnce proposals have a sponsor, they are assigned to the sponsor and are tagged `draft`\n\n.\n## Communication\n\n### Core Maintainer Meetings\n\nThe core maintainer group meets on a bi-weekly basis to discuss proposals and the project. Notes on proposals should be made public. The core maintainer group will strive to meet in person every 3-6 months.\n### Public Chat\n\nThe MCP project maintains a public Discord server with open chats for interest groups. The MCP project may have private channels for certain communications.\n## Nominating, Confirming and Removing Maintainers\n\n### The Principles\n\n- Membership in module maintainer groups is given to\n**individuals** on merit basis after they demonstrated strong expertise of their area of work through contributions, reviews, and discussions and are aligned with the overall MCP direction.\n- For membership in the\n**maintainer** group the individual has to demonstrate strong and continued alignment with the overall MCP principles.\n- No term limits for module maintainers or core maintainers\n- Light criteria of moving working-group or sub-project maintenance to ‘emeritus’ status if they don’t actively participate over long periods of time. Each maintainer group may define the inactive period that’s appropriate for their area.\n- The membership is for an individual, not a company.\n\n### Nomination and Removal\n\n- Core Maintainers are responsible for adding and removing maintainers. They will take the consideration of existing maintainers into account.\n- The lead maintainers are responsible for adding and removing core maintainers.\n\n## Current Core Maintainers\n\n- Inna Harper\n- Basil Hosmer\n- Paul Carleton\n- Nick Cooper\n- Nick Aldridge\n- Che Liu\n- Den Delimarsky\n\n## Current Maintainers and Working Groups\n\nRefer to the maintainer list.",
    "metadata": {
      "title": "Governance and Stewardship - Model Context Protocol",
      "description": "Learn about the Model Context Protocol's governance structure and how to participate in the community",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/community/governance",
      "extracted_at": "2025-08-04T09:54:40.771096+00:00"
    },
    "word_count": 1453,
    "char_count": 9999,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:40.771174+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/faqs",
    "content": "## What is MCP?\n\nMCP (Model Context Protocol) is a standard way for AI applications and agents to connect to and work with your data sources (e.g. local files, databases, or content repositories) and tools (e.g. GitHub, Google Maps, or Puppeteer).\nThink of MCP as a universal adapter for AI applications, similar to what USB-C is for physical devices. USB-C acts as a universal adapter to connect devices to various peripherals and accessories. Similarly, MCP provides a standardized way to connect AI applications to different data and tools.\nBefore USB-C, you needed different cables for different connections. Similarly, before MCP, developers had to build custom connections to each data source or tool they wanted their AI application to work with—a time-consuming process that often resulted in limited functionality. Now, with MCP, developers can easily add connections to their AI applications, making their applications much more powerful from day one.\n## Why does MCP matter?\n\n### For AI application users\n\nMCP means your AI applications can access the information and tools you work with every day, making them much more helpful. Rather than AI being limited to what it already knows about, it can now understand your specific documents, data, and work context.\nFor example, by using MCP servers, applications can access your personal documents from Google Drive or data about your codebase from GitHub, providing more personalized and contextually relevant assistance.\nImagine asking an AI assistant: “Summarize last week’s team meeting notes and schedule follow-ups with everyone.”\nBy using connections to data sources powered by MCP, the AI assistant can:\n- Connect to your Google Drive through an MCP server to read meeting notes\n- Understand who needs follow-ups based on the notes\n- Connect to your calendar through another MCP server to schedule the meetings automatically\n\n### For developers\n\nMCP reduces development time and complexity when building AI applications that need to access various data sources. With MCP, developers can focus on building great AI experiences rather than repeatedly creating custom connectors.\nTraditionally, connecting applications with data sources required building custom, one-off connections for each data source and each application. This created significant duplicative work—every developer wanting to connect their AI application to Google Drive or Slack needed to build their own connection.\nMCP simplifies this by enabling developers to build MCP servers for data sources that are then reusable by various applications. For example, using the open source Google Drive MCP server, many different applications can access data from Google Drive without each developer needing to build a custom connection.\nThis open source ecosystem of MCP servers means developers can leverage existing work rather than starting from scratch, making it easier to build powerful AI applications that seamlessly integrate with the tools and data sources their users already rely on.\n## How does MCP work?\n\nMCP creates a bridge between your AI applications and your data through a straightforward system:\n**MCP servers** connect to your data sources and tools (like Google Drive or Slack)\n**MCP clients** are run by AI applications (like Claude Desktop) to connect them to these servers\n- When you give permission, your AI application discovers available MCP servers\n- The AI model can then use these connections to read information and take actions\n\nThis modular system means new capabilities can be added without changing AI applications themselves—just like adding new accessories to your computer without upgrading your entire system.\n## Who creates and maintains MCP servers?\n\nMCP servers are developed and maintained by:\n- Developers at Anthropic who build servers for common tools and data sources\n- Open source contributors who create servers for tools they use\n- Enterprise development teams building servers for their internal systems\n- Software providers making their applications AI-ready\n\nOnce an open source MCP server is created for a data source, it can be used by any MCP-compatible AI application, creating a growing ecosystem of connections. See our list of example servers, or get started building your own server.",
    "metadata": {
      "title": "FAQs - Model Context Protocol",
      "description": "Explaining MCP and why it matters in simple terms",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/faqs",
      "extracted_at": "2025-08-04T09:54:42.208047+00:00"
    },
    "word_count": 660,
    "char_count": 4271,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:42.208090+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/learn/server-concepts",
    "content": "| Building Block | Purpose | Who Controls It | Real-World Example |\n|---|---|---|---|\nTools | For AI actions | Model-controlled | Search flights, send messages, create calendar events |\nResources | For context data | Application-controlled | Documents, calendars, emails, weather data |\nPrompts | For interaction templates | User-controlled | ”Plan a vacation”, “Summarize my meetings”, “Draft an email” |\n\n| Method | Purpose | Returns |\n|---|---|---|\n`tools/list` | Discover available tools | Array of tool definitions with schemas |\n`tools/call` | Execute a specific tool | Tool execution result |\n\n`searchFlights`\n\nqueries multiple airlines and returns structured flight options. Once flights are selected, it creates a calendar event with\n`file:///path/to/document.md`\n\n. They declare MIME types for appropriate content handling and support two discovery patterns: `travel://activities/{city}/{category}`\n\nwould access filtered activity data by substituting both `{city}`\n\nand `{category}`\n\nparameters. For example, `travel://activities/barcelona/museums`\n\nwould return all museums in Barcelona. Resource Templates include metadata such as title, description, and expected MIME type, making them discoverable and self-documenting.\n| Method | Purpose | Returns |\n|---|---|---|\n`resources/list` | List available direct resources | Array of resource descriptors |\n`resources/templates/list` | Discover resource templates | Array of resource template definitions |\n`resources/read` | Retrieve resource contents | Resource data with metadata |\n`resources/subscribe` | Monitor resource changes | Subscription confirmation |\n\n`calendar://events/2024`\n\n) - To check availability`file:///Documents/Travel/passport.pdf`\n\n) - For important information`trips://history/barcelona-2023`\n\n) - User selects which past trip style to follow`origin`\n\nairport and begins to input “Bar” as the `destination`\n\nairport, the system can suggest “Barcelona (BCN)” or “Barbados (BGI)”.\n`weather://forecast/{city}`\n\nmight suggest “Paris” or “Park City”| Method | Purpose | Returns |\n|---|---|---|\n`prompts/list` | Discover available prompts | Array of prompt descriptors |\n`prompts/get` | Retrieve prompt details | Full prompt definition with arguments |\n\n`calendar://my-calendar/June-2024`\n\n(from Calendar Server)`travel://preferences/europe`\n\n(from Travel Server)`travel://past-trips/Spain-2023`\n\n(from Travel Server)",
    "metadata": {
      "title": "Server Concepts - Model Context Protocol",
      "description": "Understanding MCP server concepts",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/learn/server-concepts",
      "extracted_at": "2025-08-04T09:54:43.840051+00:00"
    },
    "word_count": 306,
    "char_count": 2395,
    "crawl_depth": 1,
    "crawled_at": "2025-08-04T09:54:43.840079+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/clients",
    "content": "| 5ire | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| AgentAI | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| AgenticFlow | ✅ | ✅ | ✅ | ✅ | ❌ | ❌ | ❓ |\n| AIQL TUUI | ✅ | ✅ | ✅ | ✅ | ✅ | ❌ | ❓ |\n| Amazon Q CLI | ❌ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Amazon Q IDE | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| Apify MCP Tester | ❌ | ❌ | ✅ | ✅ | ❌ | ❌ | ❓ |\n| Augment Code | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| BeeAI Framework | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| BoltAI | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| ChatGPT | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| ChatWise | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| Claude.ai | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| Claude Code | ✅ | ✅ | ✅ | ❌ | ❌ | ✅ | ❓ |\n| Claude Desktop App | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| Chorus | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Cline | ✅ | ❌ | ✅ | ✅ | ❌ | ❌ | ❓ |\n| CodeGPT | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Continue | ✅ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Copilot-MCP | ✅ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Cursor | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| Daydreams Agents | ✅ | ✅ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| Emacs Mcp | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| fast-agent | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\n| FlowDown | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❌ |\n| FLUJO | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Genkit | ⚠️ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Glama | ✅ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Gemini CLI | ❌ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| GenAIScript | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| GitHub Copilot coding agent | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❌ |\n| Goose | ✅ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| gptme | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| HyperAgent | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| JetBrains AI Assistant | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| Kilo Code | ✅ | ❌ | ✅ | ✅ | ❌ | ❌ | ❓ |\n| Klavis AI Slack/Discord/Web | ✅ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| LibreChat | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| LM Studio | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Lutra | ✅ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| mcp-agent | ✅ | ✅ | ✅ | ❓ | ⚠️ | ✅ | ✅ |\n| mcp-client-chatbot | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| mcp-use | ✅ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| modelcontextchat.com | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| MCPHub | ✅ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| MCPOmni-Connect | ✅ | ✅ | ✅ | ❓ | ✅ | ❌ | ❓ |\n| Memex | ✅ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Microsoft Copilot Studio | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| MindPal | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| MooPoint | ❌ | ❌ | ✅ | ❓ | ✅ | ❌ | ❓ |\n| Msty Studio | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| NVIDIA Agent Intelligence toolkit | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| OpenSumi | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| oterm | ❌ | ✅ | ✅ | ❓ | ✅ | ❌ | ❓ |\n| Postman | ✅ | ✅ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| RecurseChat | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Roo Code | ✅ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Shortwave | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Slack MCP Client | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Sourcegraph Cody | ✅ | ❌ | ❌ | ❓ | ❌ | ❌ | ❓ |\n| SpinAI | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Superinterface | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Superjoin | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| systemprompt | ✅ | ✅ | ✅ | ❓ | ✅ | ❌ | ❓ |\n| Tambo | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Tencent CloudBase AI DevKit | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| TheiaAI/TheiaIDE | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Tome | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| TypingMind App | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| VS Code GitHub Copilot | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\n| Warp | ✅ | ❌ | ✅ | ✅ | ❌ | ❌ | ❓ |\n| WhatsMCP | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |\n| Windsurf Editor | ❌ | ❌ | ✅ | ✅ | ❌ | ❌ | ❓ |\n| Witsy | ❌ | ❌ | ✅ | ❓ | ❌ | ❌ | ❓ |\n| Zed | ❌ | ✅ | ❌ | ❌ | ❌ | ❌ | ❓ |\n| Zencoder | ❌ | ❌ | ✅ | ❌ | ❌ | ❌ | ❓ |",
    "metadata": {
      "title": "Example Clients - Model Context Protocol",
      "description": "A list of applications that support MCP integrations",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/clients",
      "extracted_at": "2025-08-04T09:54:45.283619+00:00"
    },
    "word_count": 1334,
    "char_count": 3332,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:45.283686+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/quickstart/user",
    "content": "Open Claude Desktop Settings\n\nAccess Developer Settings\n\n`~/Library/Application Support/Claude/claude_desktop_config.json`\n\n`%APPDATA%\\Claude\\claude_desktop_config.json`\n\nConfigure the Filesystem Server\n\n`username`\n\nwith your actual computer username. The paths listed in the `args`\n\narray specify which directories the Filesystem Server can access. You can modify these paths or add additional directories as needed.`\"filesystem\"`\n\n: A friendly name for the server that appears in Claude Desktop`\"command\": \"npx\"`\n\n: Uses Node.js’s npx tool to run the server`\"-y\"`\n\n: Automatically confirms the installation of the server package`\"@modelcontextprotocol/server-filesystem\"`\n\n: The package name of the Filesystem ServerRestart Claude Desktop\n\nServer not showing up in Claude / hammer icon missing\n\n`claude_desktop_config.json`\n\nfile syntax`claude_desktop_config.json`\n\nare valid and that they are absolute and not relative`username`\n\nas you did in `claude_desktop_config.json`\n\n) to see if you get any errors:Getting logs from Claude Desktop\n\n`~/Library/Logs/Claude`\n\n`%APPDATA%\\Claude\\logs`\n\n`mcp.log`\n\nwill contain general logging about MCP connections and connection failures.\n`mcp-server-SERVERNAME.log`\n\nwill contain error (stderr) logging from the named server.\nTool calls failing silently\n\nNone of this is working. What do I do?\n\nENOENT error and `${APPDATA}` in paths on Windows\n\n`${APPDATA}`\n\nwithin a path, you may need to add the expanded value of `%APPDATA%`\n\nto your `env`\n\nkey in `claude_desktop_config.json`\n\n:`npx`\n\ncommand may continue to fail if you have not installed NPM globally. If NPM is already installed globally, you will find `%APPDATA%\\npm`\n\nexists on your system. If not, you can install NPM globally by running the following command:",
    "metadata": {
      "title": "Connect to Local MCP Servers - Model Context Protocol",
      "description": "Learn how to extend Claude Desktop with local MCP servers to enable file system access and other powerful integrations",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/quickstart/user",
      "extracted_at": "2025-08-04T09:54:46.657772+00:00"
    },
    "word_count": 230,
    "char_count": 1762,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:46.657794+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/examples",
    "content": "This page showcases various Model Context Protocol (MCP) servers that demonstrate the protocol’s capabilities and versatility. These servers enable Large Language Models (LLMs) to securely access tools and data sources.\n## Reference implementations\n\nThese official reference servers demonstrate core MCP features and SDK usage:\n### Current reference servers\n\n**Filesystem** - Secure file operations with configurable access controls\n**Fetch** - Web content fetching and conversion optimized for LLM usage\n**Memory** - Knowledge graph-based persistent memory system\n**Sequential Thinking** - Dynamic problem-solving through thought sequences\n\n### Archived servers (historical reference)\n\n⚠️ **Note**: The following servers have been moved to the servers-archived repository and are no longer actively maintained. They are provided for historical reference only.\n#### Data and file systems\n\n**PostgreSQL** - Read-only database access with schema inspection capabilities\n**SQLite** - Database interaction and business intelligence features\n**Google Drive** - File access and search capabilities for Google Drive\n\n**Git** - Tools to read, search, and manipulate Git repositories\n**GitHub** - Repository management, file operations, and GitHub API integration\n**GitLab** - GitLab API integration enabling project management\n**Sentry** - Retrieving and analyzing issues from Sentry.io\n\n#### Web and browser automation\n\n**Brave Search** - Web and local search using Brave’s Search API\n**Puppeteer** - Browser automation and web scraping capabilities\n\n#### Productivity and communication\n\n**Slack** - Channel management and messaging capabilities\n**Google Maps** - Location services, directions, and place details\n\n**EverArt** - AI image generation using various models\n**AWS KB Retrieval** - Retrieval from AWS Knowledge Base using Bedrock Agent Runtime\n\n## Official integrations\n\nVisit the MCP Servers Repository (Official Integrations section) for a list of MCP servers maintained by companies for their platforms.\nVisit the MCP Servers Repository (Community section) for a list of MCP servers maintained by community members.\n## Getting started\n\n### Using reference servers\n\nTypeScript-based servers can be used directly with `npx`\n\n:\nPython-based servers can be used with `uvx`\n\n(recommended) or `pip`\n\n:\n### Configuring with Claude\n\nTo use an MCP server with Claude, add it to your configuration:\n## Additional resources\n\nVisit the MCP Servers Repository (Resources section) for a collection of other resources and projects related to MCP.\nVisit our GitHub Discussions to engage with the MCP community.",
    "metadata": {
      "title": "Example Servers - Model Context Protocol",
      "description": "A list of example servers and implementations",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/examples",
      "extracted_at": "2025-08-04T09:54:47.884893+00:00"
    },
    "word_count": 361,
    "char_count": 2600,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:47.884918+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/legacy/tools/inspector",
    "content": "In-depth guide to using the MCP Inspector for testing and debugging Model Context Protocol servers\n\nThe MCP Inspector is an interactive developer tool for testing and debugging MCP servers. While the Debugging Guide covers the Inspector as part of the overall debugging toolkit, this document provides a detailed exploration of the Inspector’s features and capabilities.",
    "metadata": {
      "title": "Inspector - Model Context Protocol",
      "description": "In-depth guide to using the MCP Inspector for testing and debugging Model Context Protocol servers",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/legacy/tools/inspector",
      "extracted_at": "2025-08-04T09:54:49.107429+00:00"
    },
    "word_count": 55,
    "char_count": 370,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:49.107444+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/tutorials/building-mcp-with-llms",
    "content": "This guide will help you use LLMs to help you build custom Model Context Protocol (MCP) servers and clients. We’ll be focusing on Claude for this tutorial, but you can do this with any frontier LLM.\n## Preparing the documentation\n\nBefore starting, gather the necessary documentation to help Claude understand MCP:\n- Visit https://modelcontextprotocol.io/llms-full.txt and copy the full documentation text\n- Navigate to either the MCP TypeScript SDK or Python SDK repository\n- Copy the README files and other relevant documentation\n- Paste these documents into your conversation with Claude\n\n## Describing your server\n\nOnce you’ve provided the documentation, clearly describe to Claude what kind of server you want to build. Be specific about:\n- What resources your server will expose\n- What tools it will provide\n- Any prompts it should offer\n- What external systems it needs to interact with\n\nFor example:\n## Working with Claude\n\nWhen working with Claude on MCP servers:\n- Start with the core functionality first, then iterate to add more features\n- Ask Claude to explain any parts of the code you don’t understand\n- Request modifications or improvements as needed\n- Have Claude help you test the server and handle edge cases\n\nClaude can help implement all the key MCP features:\n- Resource management and exposure\n- Tool definitions and implementations\n- Prompt templates and handlers\n- Error handling and logging\n- Connection and transport setup\n\n## Best practices\n\nWhen building MCP servers with Claude:\n- Break down complex servers into smaller pieces\n- Test each component thoroughly before moving on\n- Keep security in mind - validate inputs and limit access appropriately\n- Document your code well for future maintenance\n- Follow MCP protocol specifications carefully\n\n## Next steps\n\nAfter Claude helps you build your server:\n- Review the generated code carefully\n- Test the server with the MCP Inspector tool\n- Connect it to Claude.app or other MCP clients\n- Iterate based on real usage and feedback\n\nRemember that Claude can help you modify and improve your server as requirements change over time.\nNeed more guidance? Just ask Claude specific questions about implementing MCP features or troubleshooting issues that arise.",
    "metadata": {
      "title": "Building MCP with LLMs - Model Context Protocol",
      "description": "Speed up your MCP development using LLMs such as Claude!",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/tutorials/building-mcp-with-llms",
      "extracted_at": "2025-08-04T09:54:50.315219+00:00"
    },
    "word_count": 360,
    "char_count": 2232,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:50.315255+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/legacy/tools/debugging",
    "content": "Effective debugging is essential when developing MCP servers or integrating them with applications. This guide covers the debugging tools and approaches available in the MCP ecosystem.\nThis guide is for macOS. Guides for other platforms are coming soon.\n\nMCP provides several tools for debugging at different levels:\n-\n**MCP Inspector**\n- Interactive debugging interface\n- Direct server testing\n- See the Inspector guide for details\n\n-\n**Claude Desktop Developer Tools**\n- Integration testing\n- Log collection\n- Chrome DevTools integration\n\n-\n**Server Logging**\n- Custom logging implementations\n- Error tracking\n- Performance monitoring\n\n\n## Debugging in Claude Desktop\n\n### Checking server status\n\nThe Claude.app interface provides basic server status information:\n-\nClick the icon to view:\n- Connected servers\n- Available prompts and resources\n\n-\nClick the “Search and tools” icon to view:\n- Tools made available to the model\n\n\n### Viewing logs\n\nReview detailed MCP logs from Claude Desktop:\nThe logs capture:\n- Server connection events\n- Configuration issues\n- Runtime errors\n- Message exchanges\n\nAccess Chrome’s developer tools inside Claude Desktop to investigate client-side errors:\n- Create a\n`developer_settings.json`\n\nfile with `allowDevTools`\n\nset to true:\n\n- Open DevTools:\n`Command-Option-Shift-i`\n\n\nNote: You’ll see two DevTools windows:\n- Main content window\n- App title bar window\n\nUse the Console panel to inspect client-side errors.\nUse the Network panel to inspect:\n- Message payloads\n- Connection timing\n\n## Common issues\n\n### Working directory\n\nWhen using MCP servers with Claude Desktop:\n- The working directory for servers launched via\n`claude_desktop_config.json`\n\nmay be undefined (like `/`\n\non macOS) since Claude Desktop could be started from anywhere\n- Always use absolute paths in your configuration and\n`.env`\n\nfiles to ensure reliable operation\n- For testing servers directly via command line, the working directory will be where you run the command\n\nFor example in `claude_desktop_config.json`\n\n, use:\nInstead of relative paths like `./data`\n\n### Environment variables\n\nMCP servers inherit only a subset of environment variables automatically, like `USER`\n\n, `HOME`\n\n, and `PATH`\n\n.\nTo override the default variables or provide your own, you can specify an `env`\n\nkey in `claude_desktop_config.json`\n\n:\n### Server initialization\n\nCommon initialization problems:\n-\n**Path Issues**\n- Incorrect server executable path\n- Missing required files\n- Permission problems\n- Try using an absolute path for\n`command`\n\n\n-\n**Configuration Errors**\n- Invalid JSON syntax\n- Missing required fields\n- Type mismatches\n\n-\n**Environment Problems**\n- Missing environment variables\n- Incorrect variable values\n- Permission restrictions\n\n\n### Connection problems\n\nWhen servers fail to connect:\n- Check Claude Desktop logs\n- Verify server process is running\n- Test standalone with Inspector\n- Verify protocol compatibility\n\n## Implementing logging\n\n### Server-side logging\n\nWhen building a server that uses the local stdio transport, all messages logged to stderr (standard error) will be captured by the host application (e.g., Claude Desktop) automatically.\nLocal MCP servers should not log messages to stdout (standard out), as this will interfere with protocol operation.\n\nFor all transports, you can also provide logging to the client by sending a log message notification:\nImportant events to log:\n- Initialization steps\n- Resource access\n- Tool execution\n- Error conditions\n- Performance metrics\n\n### Client-side logging\n\nIn client applications:\n- Enable debug logging\n- Monitor network traffic\n- Track message exchanges\n- Record error states\n\n## Debugging workflow\n\n### Development cycle\n\n-\nInitial Development\n- Use Inspector for basic testing\n- Implement core functionality\n- Add logging points\n\n-\nIntegration Testing\n- Test in Claude Desktop\n- Monitor logs\n- Check error handling\n\n\n### Testing changes\n\nTo test changes efficiently:\n**Configuration changes**: Restart Claude Desktop\n**Server code changes**: Use Command-R to reload\n**Quick iteration**: Use Inspector during development\n\n## Best practices\n\n### Logging strategy\n\n-\n**Structured Logging**\n- Use consistent formats\n- Include context\n- Add timestamps\n- Track request IDs\n\n-\n**Error Handling**\n- Log stack traces\n- Include error context\n- Track error patterns\n- Monitor recovery\n\n-\n**Performance Tracking**\n- Log operation timing\n- Monitor resource usage\n- Track message sizes\n- Measure latency\n\n\n### Security considerations\n\nWhen debugging:\n-\n**Sensitive Data**\n- Sanitize logs\n- Protect credentials\n- Mask personal information\n\n-\n**Access Control**\n- Verify permissions\n- Check authentication\n- Monitor access patterns\n\n\n## Getting help\n\nWhen encountering issues:\n-\n**First Steps**\n- Check server logs\n- Test with Inspector\n- Review configuration\n- Verify environment\n\n-\n**Support Channels**\n- GitHub issues\n- GitHub discussions\n\n-\n**Providing Information**\n- Log excerpts\n- Configuration files\n- Steps to reproduce\n- Environment details\n\n\n## Next steps",
    "metadata": {
      "title": "Debugging - Model Context Protocol",
      "description": "A comprehensive guide to debugging Model Context Protocol (MCP) integrations",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/legacy/tools/debugging",
      "extracted_at": "2025-08-04T09:54:51.648920+00:00"
    },
    "word_count": 746,
    "char_count": 5033,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:51.648969+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/lifecycle",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) defines a rigorous lifecycle for client-server\nconnections that ensures proper capability negotiation and state management.\n**Initialization**: Capability negotiation and protocol version agreement\n**Operation**: Normal protocol communication\n**Shutdown**: Graceful termination of the connection\n\n## Lifecycle Phases\n\n### Initialization\n\nThe initialization phase **MUST** be the first interaction between client and server.\nDuring this phase, the client and server:\n- Establish protocol version compatibility\n- Exchange and negotiate capabilities\n- Share implementation details\n\nThe client **MUST** initiate this phase by sending an `initialize`\n\nrequest containing:\n- Protocol version supported\n- Client capabilities\n- Client implementation information\n\nThe server **MUST** respond with its own capabilities and information:\nAfter successful initialization, the client **MUST** send an `initialized`\n\nnotification\nto indicate it is ready to begin normal operations:\n- The client\n**SHOULD NOT** send requests other than\npings before the server has responded to the\n`initialize`\n\nrequest.\n- The server\n**SHOULD NOT** send requests other than\npings and\nlogging before receiving the `initialized`\n\nnotification.\n\n#### Version Negotiation\n\nIn the `initialize`\n\nrequest, the client **MUST** send a protocol version it supports.\nThis **SHOULD** be the *latest* version supported by the client.\nIf the server supports the requested protocol version, it **MUST** respond with the same\nversion. Otherwise, the server **MUST** respond with another protocol version it\nsupports. This **SHOULD** be the *latest* version supported by the server.\nIf the client does not support the version in the server’s response, it **SHOULD**\ndisconnect.\n#### Capability Negotiation\n\nClient and server capabilities establish which optional protocol features will be\navailable during the session.\nKey capabilities include:\n| Category | Capability | Description |\n|---|\n| Client | `roots` | Ability to provide filesystem roots |\n| Client | `sampling` | Support for LLM sampling requests |\n| Client | `elicitation` | Support for server elicitation requests |\n| Client | `experimental` | Describes support for non-standard experimental features |\n| Server | `prompts` | Offers prompt templates |\n| Server | `resources` | Provides readable resources |\n| Server | `tools` | Exposes callable tools |\n| Server | `logging` | Emits structured log messages |\n| Server | `completions` | Supports argument autocompletion |\n| Server | `experimental` | Describes support for non-standard experimental features |\n\nCapability objects can describe sub-capabilities like:\n`listChanged`\n\n: Support for list change notifications (for prompts, resources, and\ntools)\n`subscribe`\n\n: Support for subscribing to individual items’ changes (resources only)\n\n### Operation\n\nDuring the operation phase, the client and server exchange messages according to the\nnegotiated capabilities.\nBoth parties **MUST**:\n- Respect the negotiated protocol version\n- Only use capabilities that were successfully negotiated\n\n### Shutdown\n\nDuring the shutdown phase, one side (usually the client) cleanly terminates the protocol\nconnection. No specific shutdown messages are defined—instead, the underlying transport\nmechanism should be used to signal connection termination:\n#### stdio\n\nFor the stdio transport, the client **SHOULD** initiate\nshutdown by:\n- First, closing the input stream to the child process (the server)\n- Waiting for the server to exit, or sending\n`SIGTERM`\n\nif the server does not exit\nwithin a reasonable time\n- Sending\n`SIGKILL`\n\nif the server does not exit within a reasonable time after `SIGTERM`\n\n\nThe server **MAY** initiate shutdown by closing its output stream to the client and\nexiting.\n#### HTTP\n\nFor HTTP transports, shutdown is indicated by closing the\nassociated HTTP connection(s).\n## Timeouts\n\nImplementations **SHOULD** establish timeouts for all sent requests, to prevent hung\nconnections and resource exhaustion. When the request has not received a success or error\nresponse within the timeout period, the sender **SHOULD** issue a cancellation\nnotification for that request and stop waiting for\na response.\nSDKs and other middleware **SHOULD** allow these timeouts to be configured on a\nper-request basis.\nImplementations **MAY** choose to reset the timeout clock when receiving a progress\nnotification corresponding to the request, as this\nimplies that work is actually happening. However, implementations **SHOULD** always\nenforce a maximum timeout, regardless of progress notifications, to limit the impact of a\nmisbehaving client or server.\n## Error Handling\n\nImplementations **SHOULD** be prepared to handle these error cases:\n- Protocol version mismatch\n- Failure to negotiate required capabilities\n- Request timeouts\n\nExample initialization error:",
    "metadata": {
      "title": "Lifecycle - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/lifecycle",
      "extracted_at": "2025-08-04T09:54:53.221971+00:00"
    },
    "word_count": 697,
    "char_count": 4890,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:53.222008+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/legacy/concepts/architecture",
    "content": "The Model Context Protocol (MCP) is built on a flexible, extensible architecture that enables seamless communication between LLM applications and integrations. This document covers the core architectural components and concepts.\n## Overview\n\nMCP follows a client-server architecture where:\n**Hosts** are LLM applications (like Claude Desktop or IDEs) that initiate connections\n**Clients** maintain 1:1 connections with servers, inside the host application\n**Servers** provide context, tools, and prompts to clients\n\n## Core components\n\n### Protocol layer\n\nThe protocol layer handles message framing, request/response linking, and high-level communication patterns.\nKey classes include:\n### Transport layer\n\nThe transport layer handles the actual communication between clients and servers. MCP supports multiple transport mechanisms:\n-\n**Stdio transport**\n- Uses standard input/output for communication\n- Ideal for local processes\n\n-\n**Streamable HTTP transport**\n- Uses HTTP with optional Server-Sent Events for streaming\n- HTTP POST for client-to-server messages\n\n\nAll transports use JSON-RPC 2.0 to exchange messages. See the specification for detailed information about the Model Context Protocol message format.\n### Message types\n\nMCP has these main types of messages:\n-\n**Requests** expect a response from the other side:\n-\n**Results** are successful responses to requests:\n-\n**Errors** indicate that a request failed:\n-\n**Notifications** are one-way messages that don’t expect a response:\n\n## Connection lifecycle\n\n### 1. Initialization\n\n- Client sends\n`initialize`\n\nrequest with protocol version and capabilities\n- Server responds with its protocol version and capabilities\n- Client sends\n`initialized`\n\nnotification as acknowledgment\n- Normal message exchange begins\n\n### 2. Message exchange\n\nAfter initialization, the following patterns are supported:\n**Request-Response**: Client or server sends requests, the other responds\n**Notifications**: Either party sends one-way messages\n\n### 3. Termination\n\nEither party can terminate the connection:\n- Clean shutdown via\n`close()`\n\n- Transport disconnection\n- Error conditions\n\n## Error handling\n\nMCP defines these standard error codes:\nSDKs and applications can define their own error codes above -32000.\nErrors are propagated through:\n- Error responses to requests\n- Error events on transports\n- Protocol-level error handlers\n\n## Implementation example\n\nHere’s a basic example of implementing an MCP server:\n## Best practices\n\n### Transport selection\n\n-\n**Local communication**\n- Use stdio transport for local processes\n- Efficient for same-machine communication\n- Simple process management\n\n-\n**Remote communication**\n- Use Streamable HTTP for scenarios requiring HTTP compatibility\n- Consider security implications including authentication and authorization\n\n\n### Message handling\n\n-\n**Request processing**\n- Validate inputs thoroughly\n- Use type-safe schemas\n- Handle errors gracefully\n- Implement timeouts\n\n-\n**Progress reporting**\n- Use progress tokens for long operations\n- Report progress incrementally\n- Include total progress when known\n\n-\n**Error management**\n- Use appropriate error codes\n- Include helpful error messages\n- Clean up resources on errors\n\n\n## Security considerations\n\n-\n**Transport security**\n- Use TLS for remote connections\n- Validate connection origins\n- Implement authentication when needed\n\n-\n**Message validation**\n- Validate all incoming messages\n- Sanitize inputs\n- Check message size limits\n- Verify JSON-RPC format\n\n-\n**Resource protection**\n- Implement access controls\n- Validate resource paths\n- Monitor resource usage\n- Rate limit requests\n\n-\n**Error handling**\n- Don’t leak sensitive information\n- Log security-relevant errors\n- Implement proper cleanup\n- Handle DoS scenarios\n\n\n## Debugging and monitoring\n\n-\n**Logging**\n- Log protocol events\n- Track message flow\n- Monitor performance\n- Record errors\n\n-\n**Diagnostics**\n- Implement health checks\n- Monitor connection state\n- Track resource usage\n- Profile performance\n\n-\n**Testing**\n- Test different transports\n- Verify error handling\n- Check edge cases\n- Load test servers",
    "metadata": {
      "title": "Core architecture - Model Context Protocol",
      "description": "Understand how MCP connects clients, servers, and LLMs",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/legacy/concepts/architecture",
      "extracted_at": "2025-08-04T09:54:54.898125+00:00"
    },
    "word_count": 578,
    "char_count": 4121,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:54.898169+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/latest",
    "content": "Model Context Protocol (MCP) is an open protocol that\nenables seamless integration between LLM applications and external data sources and\ntools. Whether you’re building an AI-powered IDE, enhancing a chat interface, or creating\ncustom AI workflows, MCP provides a standardized way to connect LLMs with the context\nthey need.\nThis specification defines the authoritative protocol requirements, based on the\nTypeScript schema in\nschema.ts.\nFor implementation guides and examples, visit\nmodelcontextprotocol.io.\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD\nNOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be\ninterpreted as described in BCP 14\n[RFC2119]\n[RFC8174] when, and only when, they\nappear in all capitals, as shown here.\n## Overview\n\nMCP provides a standardized way for applications to:\n- Share contextual information with language models\n- Expose tools and capabilities to AI systems\n- Build composable integrations and workflows\n\nThe protocol uses JSON-RPC 2.0 messages to establish\ncommunication between:\n**Hosts**: LLM applications that initiate connections\n**Clients**: Connectors within the host application\n**Servers**: Services that provide context and capabilities\n\nMCP takes some inspiration from the\nLanguage Server Protocol, which\nstandardizes how to add support for programming languages across a whole ecosystem of\ndevelopment tools. In a similar way, MCP standardizes how to integrate additional context\nand tools into the ecosystem of AI applications.\n## Key Details\n\n### Base Protocol\n\n- JSON-RPC message format\n- Stateful connections\n- Server and client capability negotiation\n\n### Features\n\nServers offer any of the following features to clients:\n**Resources**: Context and data, for the user or the AI model to use\n**Prompts**: Templated messages and workflows for users\n**Tools**: Functions for the AI model to execute\n\nClients may offer the following features to servers:\n**Sampling**: Server-initiated agentic behaviors and recursive LLM interactions\n**Roots**: Server-initiated inquiries into uri or filesystem boundaries to operate in\n**Elicitation**: Server-initiated requests for additional information from users\n\n### Additional Utilities\n\n- Configuration\n- Progress tracking\n- Cancellation\n- Error reporting\n- Logging\n\n## Security and Trust & Safety\n\nThe Model Context Protocol enables powerful capabilities through arbitrary data access\nand code execution paths. With this power comes important security and trust\nconsiderations that all implementors must carefully address.\n### Key Principles\n\n-\n**User Consent and Control**\n- Users must explicitly consent to and understand all data access and operations\n- Users must retain control over what data is shared and what actions are taken\n- Implementors should provide clear UIs for reviewing and authorizing activities\n\n-\n**Data Privacy**\n- Hosts must obtain explicit user consent before exposing user data to servers\n- Hosts must not transmit resource data elsewhere without user consent\n- User data should be protected with appropriate access controls\n\n-\n**Tool Safety**\n- Tools represent arbitrary code execution and must be treated with appropriate\ncaution.\n- In particular, descriptions of tool behavior such as annotations should be\nconsidered untrusted, unless obtained from a trusted server.\n\n- Hosts must obtain explicit user consent before invoking any tool\n- Users should understand what each tool does before authorizing its use\n\n-\n**LLM Sampling Controls**\n- Users must explicitly approve any LLM sampling requests\n- Users should control:\n- Whether sampling occurs at all\n- The actual prompt that will be sent\n- What results the server can see\n\n- The protocol intentionally limits server visibility into prompts\n\n\n### Implementation Guidelines\n\nWhile MCP itself cannot enforce these security principles at the protocol level,\nimplementors **SHOULD**:\n- Build robust consent and authorization flows into their applications\n- Provide clear documentation of security implications\n- Implement appropriate access controls and data protections\n- Follow security best practices in their integrations\n- Consider privacy implications in their feature designs\n\n## Learn More\n\nExplore the detailed specification for each protocol component:",
    "metadata": {
      "title": "Specification - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/latest",
      "extracted_at": "2025-08-04T09:54:56.388710+00:00"
    },
    "word_count": 622,
    "char_count": 4304,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:56.388746+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/client/roots",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for clients to expose\nfilesystem “roots” to servers. Roots define the boundaries of where servers can operate\nwithin the filesystem, allowing them to understand which directories and files they have\naccess to. Servers can request the list of roots from supporting clients and receive\nnotifications when that list changes.\n## User Interaction Model\n\nRoots in MCP are typically exposed through workspace or project configuration interfaces.\nFor example, implementations could offer a workspace/project picker that allows users to\nselect directories and files the server should have access to. This can be combined with\nautomatic workspace detection from version control systems or project files.\nHowever, implementations are free to expose roots through any interface pattern that\nsuits their needs—the protocol itself does not mandate any specific user\ninteraction model.\n## Capabilities\n\nClients that support roots **MUST** declare the `roots`\n\ncapability during\ninitialization:\n`listChanged`\n\nindicates whether the client will emit notifications when the list of roots\nchanges.\n## Protocol Messages\n\n### Listing Roots\n\nTo retrieve roots, servers send a `roots/list`\n\nrequest:\n**Request:**\n**Response:**\n### Root List Changes\n\nWhen roots change, clients that support `listChanged`\n\n**MUST** send a notification:\n## Message Flow\n\n## Data Types\n\n### Root\n\nA root definition includes:\n`uri`\n\n: Unique identifier for the root. This **MUST** be a `file://`\n\nURI in the current\nspecification.\n`name`\n\n: Optional human-readable name for display purposes.\n\nExample roots for different use cases:\n#### Project Directory\n\n#### Multiple Repositories\n\n## Error Handling\n\nClients **SHOULD** return standard JSON-RPC errors for common failure cases:\n- Client does not support roots:\n`-32601`\n\n(Method not found)\n- Internal errors:\n`-32603`\n\n\nExample error:\n## Security Considerations\n\n-\nClients\n**MUST**:\n- Only expose roots with appropriate permissions\n- Validate all root URIs to prevent path traversal\n- Implement proper access controls\n- Monitor root accessibility\n\n-\nServers\n**SHOULD**:\n- Handle cases where roots become unavailable\n- Respect root boundaries during operations\n- Validate all paths against provided roots\n\n\n## Implementation Guidelines\n\n-\nClients\n**SHOULD**:\n- Prompt users for consent before exposing roots to servers\n- Provide clear user interfaces for root management\n- Validate root accessibility before exposing\n- Monitor for root changes\n\n-\nServers\n**SHOULD**:\n- Check for roots capability before usage\n- Handle root list changes gracefully\n- Respect root boundaries in operations\n- Cache root information appropriately",
    "metadata": {
      "title": "Roots - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/client/roots",
      "extracted_at": "2025-08-04T09:54:57.874087+00:00"
    },
    "word_count": 391,
    "char_count": 2728,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:57.874119+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/development/contributing",
    "content": "How to participate in Model Context Protocol development\n\nWe welcome contributions from the community! Please review our contributing guidelines for details on how to submit changes.All contributors must adhere to our Code of Conduct.For questions and discussions, please use GitHub Discussions.",
    "metadata": {
      "title": "Contributing - Model Context Protocol",
      "description": "How to participate in Model Context Protocol development",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/development/contributing",
      "extracted_at": "2025-08-04T09:54:59.346443+00:00"
    },
    "word_count": 41,
    "char_count": 295,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:54:59.346455+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/server",
    "content": "**Protocol Revision**: 2025-06-18\n\nServers provide the fundamental building blocks for adding context to language models via\nMCP. These primitives enable rich interactions between clients, servers, and language\nmodels:\n**Prompts**: Pre-defined templates or instructions that guide language model\ninteractions\n**Resources**: Structured data or content that provides additional context to the model\n**Tools**: Executable functions that allow models to perform actions or retrieve\ninformation\n\nEach primitive can be summarized in the following control hierarchy:\n| Primitive | Control | Description | Example |\n|---|\n| Prompts | User-controlled | Interactive templates invoked by user choice | Slash commands, menu options |\n| Resources | Application-controlled | Contextual data attached and managed by the client | File contents, git history |\n| Tools | Model-controlled | Functions exposed to the LLM to take actions | API POST requests, file writing |\n\nExplore these key primitives in more detail below:",
    "metadata": {
      "title": "Overview - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/server",
      "extracted_at": "2025-08-04T09:55:00.811407+00:00"
    },
    "word_count": 146,
    "char_count": 1004,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:00.811426+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol consists of several key components that work together:\n**Base Protocol**: Core JSON-RPC message types\n**Lifecycle Management**: Connection initialization, capability negotiation, and\nsession control\n**Authorization**: Authentication and authorization framework for HTTP-based transports\n**Server Features**: Resources, prompts, and tools exposed by servers\n**Client Features**: Sampling and root directory lists provided by clients\n**Utilities**: Cross-cutting concerns like logging and argument completion\n\nAll implementations **MUST** support the base protocol and lifecycle management\ncomponents. Other components **MAY** be implemented based on the specific needs of the\napplication.\nThese protocol layers establish clear separation of concerns while enabling rich\ninteractions between clients and servers. The modular design allows implementations to\nsupport exactly the features they need.\n## Messages\n\nAll messages between MCP clients and servers **MUST** follow the\nJSON-RPC 2.0 specification. The protocol defines\nthese types of messages:\n### Requests\n\nRequests are sent from the client to the server or vice versa, to initiate an operation.\n- Requests\n**MUST** include a string or integer ID.\n- Unlike base JSON-RPC, the ID\n**MUST NOT** be `null`\n\n.\n- The request ID\n**MUST NOT** have been previously used by the requestor within the same\nsession.\n\n### Responses\n\nResponses are sent in reply to requests, containing the result or error of the operation.\n- Responses\n**MUST** include the same ID as the request they correspond to.\n**Responses** are further sub-categorized as either **successful results** or\n**errors**. Either a `result`\n\nor an `error`\n\n**MUST** be set. A response **MUST NOT**\nset both.\n- Results\n**MAY** follow any JSON object structure, while errors **MUST** include an\nerror code and message at minimum.\n- Error codes\n**MUST** be integers.\n\n### Notifications\n\nNotifications are sent from the client to the server or vice versa, as a one-way message.\nThe receiver **MUST NOT** send a response.\n- Notifications\n**MUST NOT** include an ID.\n\n## Auth\n\nMCP provides an Authorization framework for use with HTTP.\nImplementations using an HTTP-based transport **SHOULD** conform to this specification,\nwhereas implementations using STDIO transport **SHOULD NOT** follow this specification,\nand instead retrieve credentials from the environment.\nAdditionally, clients and servers **MAY** negotiate their own custom authentication and\nauthorization strategies.\nFor further discussions and contributions to the evolution of MCP’s auth mechanisms, join\nus in\nGitHub Discussions\nto help shape the future of the protocol!\n## Schema\n\nThe full specification of the protocol is defined as a\nTypeScript schema.\nThis is the source of truth for all protocol messages and structures.\nThere is also a\nJSON Schema,\nwhich is automatically generated from the TypeScript source of truth, for use with\nvarious automated tooling.\n### General fields\n\nThe `_meta`\n\nproperty/parameter is reserved by MCP to allow clients and servers\nto attach additional metadata to their interactions.\nCertain key names are reserved by MCP for protocol-level metadata, as specified below;\nimplementations MUST NOT make assumptions about values at these keys.\nAdditionally, definitions in the schema\nmay reserve particular names for purpose-specific metadata, as declared in those definitions.\n**Key name format:** valid `_meta`\n\nkey names have two segments: an optional **prefix**, and a **name**.\n**Prefix:**\n- If specified, MUST be a series of labels separated by dots (\n`.`\n\n), followed by a slash (`/`\n\n).\n- Labels MUST start with a letter and end with a letter or digit; interior characters can be letters, digits, or hyphens (\n`-`\n\n).\n\n- Any prefix beginning with zero or more valid labels, followed by\n`modelcontextprotocol`\n\nor `mcp`\n\n, followed by any valid label,\nis **reserved** for MCP use.\n- For example:\n`modelcontextprotocol.io/`\n\n, `mcp.dev/`\n\n, `api.modelcontextprotocol.org/`\n\n, and `tools.mcp.com/`\n\nare all reserved.\n\n\n**Name:**\n- Unless empty, MUST begin and end with an alphanumeric character (\n`[a-z0-9A-Z]`\n\n).\n- MAY contain hyphens (\n`-`\n\n), underscores (`_`\n\n), dots (`.`\n\n), and alphanumerics in between.",
    "metadata": {
      "title": "Overview - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic",
      "extracted_at": "2025-08-04T09:55:02.314223+00:00"
    },
    "word_count": 627,
    "char_count": 4277,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:02.314266+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io",
    "content": "AI-enabled tools are powerful, but they’re often limited to the information you manually provide or require bespoke integrations.\n\nWhether it’s reading files from your computer, searching through an\ninternal or external knowledge base, or updating tasks in an project\nmanagement tool, MCP provides a secure, standardized, *simple* way\nto give AI systems the context they need.\n\nPick from pre-built servers for popular tools like GitHub, Google Drive, Slack and hundreds of others. Combine multiple servers for complete workflows, or easily build your own for custom integrations.\n\nConfigure your AI application (like Claude, VS Code, or ChatGPT) to connect to your MCP servers. The application can now see available tools, resources and prompts from all connected servers.\n\nYour AI-powered application can now access real data, execute actions, and provide more helpful responses based on your actual context.",
    "metadata": {
      "title": "Model Context Protocol - Model Context Protocol",
      "description": "The open protocol that connects AI applications to the systems where context lives",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io",
      "extracted_at": "2025-08-04T09:55:03.773710+00:00"
    },
    "word_count": 136,
    "char_count": 909,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:03.773750+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/transports",
    "content": "**Protocol Revision**: 2025-06-18\n\nMCP uses JSON-RPC to encode messages. JSON-RPC messages **MUST** be UTF-8 encoded.\nThe protocol currently defines two standard transport mechanisms for client-server\ncommunication:\n- stdio, communication over standard in and standard out\n- Streamable HTTP\n\nClients **SHOULD** support stdio whenever possible.\nIt is also possible for clients and servers to implement\ncustom transports in a pluggable fashion.\n## stdio\n\nIn the **stdio** transport:\n- The client launches the MCP server as a subprocess.\n- The server reads JSON-RPC messages from its standard input (\n`stdin`\n\n) and sends messages\nto its standard output (`stdout`\n\n).\n- Messages are individual JSON-RPC requests, notifications, or responses.\n- Messages are delimited by newlines, and\n**MUST NOT** contain embedded newlines.\n- The server\n**MAY** write UTF-8 strings to its standard error (`stderr`\n\n) for logging\npurposes. Clients **MAY** capture, forward, or ignore this logging.\n- The server\n**MUST NOT** write anything to its `stdout`\n\nthat is not a valid MCP message.\n- The client\n**MUST NOT** write anything to the server’s `stdin`\n\nthat is not a valid MCP\nmessage.\n\n## Streamable HTTP\n\nIn the **Streamable HTTP** transport, the server operates as an independent process that\ncan handle multiple client connections. This transport uses HTTP POST and GET requests.\nServer can optionally make use of\nServer-Sent Events (SSE) to stream\nmultiple server messages. This permits basic MCP servers, as well as more feature-rich\nservers supporting streaming and server-to-client notifications and requests.\nThe server **MUST** provide a single HTTP endpoint path (hereafter referred to as the\n**MCP endpoint**) that supports both POST and GET methods. For example, this could be a\nURL like `https://example.com/mcp`\n\n.\n#### Security Warning\n\nWhen implementing Streamable HTTP transport:\n- Servers\n**MUST** validate the `Origin`\n\nheader on all incoming connections to prevent DNS rebinding attacks\n- When running locally, servers\n**SHOULD** bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)\n- Servers\n**SHOULD** implement proper authentication for all connections\n\nWithout these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.\n### Sending Messages to the Server\n\nEvery JSON-RPC message sent from the client **MUST** be a new HTTP POST request to the\nMCP endpoint.\n- The client\n**MUST** use HTTP POST to send JSON-RPC messages to the MCP endpoint.\n- The client\n**MUST** include an `Accept`\n\nheader, listing both `application/json`\n\nand\n`text/event-stream`\n\nas supported content types.\n- The body of the POST request\n**MUST** be a single JSON-RPC *request*, *notification*, or *response*.\n- If the input is a JSON-RPC\n*response* or *notification*:\n- If the server accepts the input, the server\n**MUST** return HTTP status code 202\nAccepted with no body.\n- If the server cannot accept the input, it\n**MUST** return an HTTP error status code\n(e.g., 400 Bad Request). The HTTP response body **MAY** comprise a JSON-RPC *error\nresponse* that has no `id`\n\n.\n\n- If the input is a JSON-RPC\n*request*, the server **MUST** either\nreturn `Content-Type: text/event-stream`\n\n, to initiate an SSE stream, or\n`Content-Type: application/json`\n\n, to return one JSON object. The client **MUST**\nsupport both these cases.\n- If the server initiates an SSE stream:\n- The SSE stream\n**SHOULD** eventually include JSON-RPC *response* for the\nJSON-RPC *request* sent in the POST body.\n- The server\n**MAY** send JSON-RPC *requests* and *notifications* before sending the\nJSON-RPC *response*. These messages **SHOULD** relate to the originating client\n*request*.\n- The server\n**SHOULD NOT** close the SSE stream before sending the JSON-RPC *response*\nfor the received JSON-RPC *request*, unless the session\nexpires.\n- After the JSON-RPC\n*response* has been sent, the server **SHOULD** close the SSE\nstream.\n- Disconnection\n**MAY** occur at any time (e.g., due to network conditions).\nTherefore:\n- Disconnection\n**SHOULD NOT** be interpreted as the client cancelling its request.\n- To cancel, the client\n**SHOULD** explicitly send an MCP `CancelledNotification`\n\n.\n- To avoid message loss due to disconnection, the server\n**MAY** make the stream\nresumable.\n\n\n\n### Listening for Messages from the Server\n\n- The client\n**MAY** issue an HTTP GET to the MCP endpoint. This can be used to open an\nSSE stream, allowing the server to communicate to the client, without the client first\nsending data via HTTP POST.\n- The client\n**MUST** include an `Accept`\n\nheader, listing `text/event-stream`\n\nas a\nsupported content type.\n- The server\n**MUST** either return `Content-Type: text/event-stream`\n\nin response to\nthis HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server\ndoes not offer an SSE stream at this endpoint.\n- If the server initiates an SSE stream:\n- The server\n**MAY** send JSON-RPC *requests* and *notifications* on the stream.\n- These messages\n**SHOULD** be unrelated to any concurrently-running JSON-RPC\n*request* from the client.\n- The server\n**MUST NOT** send a JSON-RPC *response* on the stream **unless**\nresuming a stream associated with a previous client\nrequest.\n- The server\n**MAY** close the SSE stream at any time.\n- The client\n**MAY** close the SSE stream at any time.\n\n\n### Multiple Connections\n\n- The client\n**MAY** remain connected to multiple SSE streams simultaneously.\n- The server\n**MUST** send each of its JSON-RPC messages on only one of the connected\nstreams; that is, it **MUST NOT** broadcast the same message across multiple streams.\n- The risk of message loss\n**MAY** be mitigated by making the stream\nresumable.\n\n\n### Resumability and Redelivery\n\nTo support resuming broken connections, and redelivering messages that might otherwise be\nlost:\n- Servers\n**MAY** attach an `id`\n\nfield to their SSE events, as described in the\nSSE standard.\n- If present, the ID\n**MUST** be globally unique across all streams within that\nsession—or all streams with that specific client, if session\nmanagement is not in use.\n\n- If the client wishes to resume after a broken connection, it\n**SHOULD** issue an HTTP\nGET to the MCP endpoint, and include the\n`Last-Event-ID`\n\nheader to indicate the last event ID it received.\n- The server\n**MAY** use this header to replay messages that would have been sent\nafter the last event ID, *on the stream that was disconnected*, and to resume the\nstream from that point.\n- The server\n**MUST NOT** replay messages that would have been delivered on a\ndifferent stream.\n\n\nIn other words, these event IDs should be assigned by servers on a *per-stream* basis, to\nact as a cursor within that particular stream.\n### Session Management\n\nAn MCP “session” consists of logically related interactions between a client and a\nserver, beginning with the initialization phase. To support\nservers which want to establish stateful sessions:\n- A server using the Streamable HTTP transport\n**MAY** assign a session ID at\ninitialization time, by including it in an `Mcp-Session-Id`\n\nheader on the HTTP\nresponse containing the `InitializeResult`\n\n.\n- The session ID\n**SHOULD** be globally unique and cryptographically secure (e.g., a\nsecurely generated UUID, a JWT, or a cryptographic hash).\n- The session ID\n**MUST** only contain visible ASCII characters (ranging from 0x21 to\n0x7E).\n\n- If an\n`Mcp-Session-Id`\n\nis returned by the server during initialization, clients using\nthe Streamable HTTP transport **MUST** include it in the `Mcp-Session-Id`\n\nheader on\nall of their subsequent HTTP requests.\n- Servers that require a session ID\n**SHOULD** respond to requests without an\n`Mcp-Session-Id`\n\nheader (other than initialization) with HTTP 400 Bad Request.\n\n- The server\n**MAY** terminate the session at any time, after which it **MUST** respond\nto requests containing that session ID with HTTP 404 Not Found.\n- When a client receives HTTP 404 in response to a request containing an\n`Mcp-Session-Id`\n\n, it **MUST** start a new session by sending a new `InitializeRequest`\n\nwithout a session ID attached.\n- Clients that no longer need a particular session (e.g., because the user is leaving\nthe client application)\n**SHOULD** send an HTTP DELETE to the MCP endpoint with the\n`Mcp-Session-Id`\n\nheader, to explicitly terminate the session.\n- The server\n**MAY** respond to this request with HTTP 405 Method Not Allowed,\nindicating that the server does not allow clients to terminate sessions.\n\n\n### Sequence Diagram\n\nIf using HTTP, the client **MUST** include the `MCP-Protocol-Version: <protocol-version>`\n\nHTTP header on all subsequent requests to the MCP\nserver, allowing the MCP server to respond based on the MCP protocol version.\nFor example: `MCP-Protocol-Version: 2025-06-18`\n\nThe protocol version sent by the client **SHOULD** be the one negotiated during\ninitialization.\nFor backwards compatibility, if the server does *not* receive an `MCP-Protocol-Version`\n\nheader, and has no other way to identify the version - for example, by relying on the\nprotocol version negotiated during initialization - the server **SHOULD** assume protocol\nversion `2025-03-26`\n\n.\nIf the server receives a request with an invalid or unsupported\n`MCP-Protocol-Version`\n\n, it **MUST** respond with `400 Bad Request`\n\n.\n### Backwards Compatibility\n\nClients and servers can maintain backwards compatibility with the deprecated HTTP+SSE\ntransport (from\nprotocol version 2024-11-05) as follows:\n**Servers** wanting to support older clients should:\n- Continue to host both the SSE and POST endpoints of the old transport, alongside the\nnew “MCP endpoint” defined for the Streamable HTTP transport.\n- It is also possible to combine the old POST endpoint and the new MCP endpoint, but\nthis may introduce unneeded complexity.\n\n\n**Clients** wanting to support older servers should:\n- Accept an MCP server URL from the user, which may point to either a server using the\nold transport or the new transport.\n- Attempt to POST an\n`InitializeRequest`\n\nto the server URL, with an `Accept`\n\nheader as\ndefined above:\n- If it succeeds, the client can assume this is a server supporting the new Streamable\nHTTP transport.\n- If it fails with an HTTP 4xx status code (e.g., 405 Method Not Allowed or 404 Not\nFound):\n- Issue a GET request to the server URL, expecting that this will open an SSE stream\nand return an\n`endpoint`\n\nevent as the first event.\n- When the\n`endpoint`\n\nevent arrives, the client can assume this is a server running\nthe old HTTP+SSE transport, and should use that transport for all subsequent\ncommunication.\n\n\n\n## Custom Transports\n\nClients and servers **MAY** implement additional custom transport mechanisms to suit\ntheir specific needs. The protocol is transport-agnostic and can be implemented over any\ncommunication channel that supports bidirectional message exchange.\nImplementers who choose to support custom transports **MUST** ensure they preserve the\nJSON-RPC message format and lifecycle requirements defined by MCP. Custom transports\n**SHOULD** document their specific connection establishment and message exchange patterns\nto aid interoperability.",
    "metadata": {
      "title": "Transports - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/transports",
      "extracted_at": "2025-08-04T09:55:04.992841+00:00"
    },
    "word_count": 1723,
    "char_count": 11149,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:04.992932+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/prompts",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for servers to expose prompt\ntemplates to clients. Prompts allow servers to provide structured messages and\ninstructions for interacting with language models. Clients can discover available\nprompts, retrieve their contents, and provide arguments to customize them.\n## User Interaction Model\n\nPrompts are designed to be **user-controlled**, meaning they are exposed from servers to\nclients with the intention of the user being able to explicitly select them for use.\nTypically, prompts would be triggered through user-initiated commands in the user\ninterface, which allows users to naturally discover and invoke available prompts.\nFor example, as slash commands:\nHowever, implementors are free to expose prompts through any interface pattern that suits\ntheir needs—the protocol itself does not mandate any specific user interaction\nmodel.\n## Capabilities\n\nServers that support prompts **MUST** declare the `prompts`\n\ncapability during\ninitialization:\n`listChanged`\n\nindicates whether the server will emit notifications when the list of\navailable prompts changes.\n## Protocol Messages\n\n### Listing Prompts\n\nTo retrieve available prompts, clients send a `prompts/list`\n\nrequest. This operation\nsupports pagination.\n**Request:**\n**Response:**\n### Getting a Prompt\n\nTo retrieve a specific prompt, clients send a `prompts/get`\n\nrequest. Arguments may be\nauto-completed through the completion API.\n**Request:**\n**Response:**\n### List Changed Notification\n\nWhen the list of available prompts changes, servers that declared the `listChanged`\n\ncapability **SHOULD** send a notification:\n## Message Flow\n\n## Data Types\n\n### Prompt\n\nA prompt definition includes:\n`name`\n\n: Unique identifier for the prompt\n`title`\n\n: Optional human-readable name of the prompt for display purposes.\n`description`\n\n: Optional human-readable description\n`arguments`\n\n: Optional list of arguments for customization\n\n### PromptMessage\n\nMessages in a prompt can contain:\n`role`\n\n: Either “user” or “assistant” to indicate the speaker\n`content`\n\n: One of the following content types:\n\nAll content types in prompt messages support optional\nannotations for\nmetadata about audience, priority, and modification times.\n#### Text Content\n\nText content represents plain text messages:\nThis is the most common content type used for natural language interactions.\n#### Image Content\n\nImage content allows including visual information in messages:\nThe image data **MUST** be base64-encoded and include a valid MIME type. This enables\nmulti-modal interactions where visual context is important.\n#### Audio Content\n\nAudio content allows including audio information in messages:\nThe audio data MUST be base64-encoded and include a valid MIME type. This enables\nmulti-modal interactions where audio context is important.\n#### Embedded Resources\n\nEmbedded resources allow referencing server-side resources directly in messages:\nResources can contain either text or binary (blob) data and **MUST** include:\n- A valid resource URI\n- The appropriate MIME type\n- Either text content or base64-encoded blob data\n\nEmbedded resources enable prompts to seamlessly incorporate server-managed content like\ndocumentation, code samples, or other reference materials directly into the conversation\nflow.\n## Error Handling\n\nServers **SHOULD** return standard JSON-RPC errors for common failure cases:\n- Invalid prompt name:\n`-32602`\n\n(Invalid params)\n- Missing required arguments:\n`-32602`\n\n(Invalid params)\n- Internal errors:\n`-32603`\n\n(Internal error)\n\n## Implementation Considerations\n\n- Servers\n**SHOULD** validate prompt arguments before processing\n- Clients\n**SHOULD** handle pagination for large prompt lists\n- Both parties\n**SHOULD** respect capability negotiation\n\n## Security\n\nImplementations **MUST** carefully validate all prompt inputs and outputs to prevent\ninjection attacks or unauthorized access to resources.",
    "metadata": {
      "title": "Prompts - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/prompts",
      "extracted_at": "2025-08-04T09:55:06.523726+00:00"
    },
    "word_count": 541,
    "char_count": 3958,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:06.523765+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/architecture",
    "content": "The Model Context Protocol (MCP) follows a client-host-server architecture where each\nhost can run multiple client instances. This architecture enables users to integrate AI\ncapabilities across applications while maintaining clear security boundaries and\nisolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused\non context exchange and sampling coordination between clients and servers.\n## Core Components\n\n### Host\n\nThe host process acts as the container and coordinator:\n- Creates and manages multiple client instances\n- Controls client connection permissions and lifecycle\n- Enforces security policies and consent requirements\n- Handles user authorization decisions\n- Coordinates AI/LLM integration and sampling\n- Manages context aggregation across clients\n\n### Clients\n\nEach client is created by the host and maintains an isolated server connection:\n- Establishes one stateful session per server\n- Handles protocol negotiation and capability exchange\n- Routes protocol messages bidirectionally\n- Manages subscriptions and notifications\n- Maintains security boundaries between servers\n\nA host application creates and manages multiple clients, with each client having a 1:1\nrelationship with a particular server.\n### Servers\n\nServers provide specialized context and capabilities:\n- Expose resources, tools and prompts via MCP primitives\n- Operate independently with focused responsibilities\n- Request sampling through client interfaces\n- Must respect security constraints\n- Can be local processes or remote services\n\n## Design Principles\n\nMCP is built on several key design principles that inform its architecture and\nimplementation:\n-\n**Servers should be extremely easy to build**\n- Host applications handle complex orchestration responsibilities\n- Servers focus on specific, well-defined capabilities\n- Simple interfaces minimize implementation overhead\n- Clear separation enables maintainable code\n\n-\n**Servers should be highly composable**\n- Each server provides focused functionality in isolation\n- Multiple servers can be combined seamlessly\n- Shared protocol enables interoperability\n- Modular design supports extensibility\n\n-\n**Servers should not be able to read the whole conversation, nor “see into” other\nservers**\n- Servers receive only necessary contextual information\n- Full conversation history stays with the host\n- Each server connection maintains isolation\n- Cross-server interactions are controlled by the host\n- Host process enforces security boundaries\n\n-\n**Features can be added to servers and clients progressively**\n- Core protocol provides minimal required functionality\n- Additional capabilities can be negotiated as needed\n- Servers and clients evolve independently\n- Protocol designed for future extensibility\n- Backwards compatibility is maintained\n\n\n## Capability Negotiation\n\nThe Model Context Protocol uses a capability-based negotiation system where clients and\nservers explicitly declare their supported features during initialization. Capabilities\ndetermine which protocol features and primitives are available during a session.\n- Servers declare capabilities like resource subscriptions, tool support, and prompt\ntemplates\n- Clients declare capabilities like sampling support and notification handling\n- Both parties must respect declared capabilities throughout the session\n- Additional capabilities can be negotiated through extensions to the protocol\n\nEach capability unlocks specific protocol features for use during the session. For\nexample:\n- Implemented server features must be advertised in the\nserver’s capabilities\n- Emitting resource subscription notifications requires the server to declare\nsubscription support\n- Tool invocation requires the server to declare tool capabilities\n- Sampling requires the client to declare support in its\ncapabilities\n\nThis capability negotiation ensures clients and servers have a clear understanding of\nsupported functionality while maintaining protocol extensibility.",
    "metadata": {
      "title": "Architecture - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/architecture",
      "extracted_at": "2025-08-04T09:55:07.741667+00:00"
    },
    "word_count": 541,
    "char_count": 3982,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:07.741706+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation",
    "content": "**Protocol Revision**: 2025-06-18\n\nElicitation is newly introduced in this version of the MCP specification and its design may evolve in future protocol versions.\n\nThe Model Context Protocol (MCP) provides a standardized way for servers to request additional\ninformation from users through the client during interactions. This flow allows clients to\nmaintain control over user interactions and data sharing while enabling servers to gather\nnecessary information dynamically.\nServers request structured data from users with JSON schemas to validate responses.\n## User Interaction Model\n\nElicitation in MCP allows servers to implement interactive workflows by enabling user input\nrequests to occur *nested* inside other MCP server features.\nImplementations are free to expose elicitation through any interface pattern that suits\ntheir needs—the protocol itself does not mandate any specific user interaction\nmodel.\nFor trust & safety and security:\n- Servers\n**MUST NOT** use elicitation to request sensitive information.\n\nApplications **SHOULD**:\n- Provide UI that makes it clear which server is requesting information\n- Allow users to review and modify their responses before sending\n- Respect user privacy and provide clear decline and cancel options\n\n## Capabilities\n\nClients that support elicitation **MUST** declare the `elicitation`\n\ncapability during\ninitialization:\n## Protocol Messages\n\n### Creating Elicitation Requests\n\nTo request information from a user, servers send an `elicitation/create`\n\nrequest:\n#### Simple Text Request\n\n**Request:**\n**Response:**\n#### Structured Data Request\n\n**Request:**\n**Response:**\n**Reject Response Example:**\n**Cancel Response Example:**\n## Message Flow\n\n## Request Schema\n\nThe `requestedSchema`\n\nfield allows servers to define the structure of the expected response using a restricted subset of JSON Schema. To simplify implementation for clients, elicitation schemas are limited to flat objects with primitive properties only:\n### Supported Schema Types\n\nThe schema is restricted to these primitive types:\n-\n**String Schema**\nSupported formats: `email`\n\n, `uri`\n\n, `date`\n\n, `date-time`\n\n-\n**Number Schema**\n-\n**Boolean Schema**\n-\n**Enum Schema**\n\nClients can use this schema to:\n- Generate appropriate input forms\n- Validate user input before sending\n- Provide better guidance to users\n\nNote that complex nested structures, arrays of objects, and other advanced JSON Schema features are intentionally not supported to simplify client implementation.\n## Response Actions\n\nElicitation responses use a three-action model to clearly distinguish between different user actions:\nThe three response actions are:\n-\n**Accept** (`action: \"accept\"`\n\n): User explicitly approved and submitted with data\n- The\n`content`\n\nfield contains the submitted data matching the requested schema\n- Example: User clicked “Submit”, “OK”, “Confirm”, etc.\n\n-\n**Decline** (`action: \"decline\"`\n\n): User explicitly declined the request\n- The\n`content`\n\nfield is typically omitted\n- Example: User clicked “Reject”, “Decline”, “No”, etc.\n\n-\n**Cancel** (`action: \"cancel\"`\n\n): User dismissed without making an explicit choice\n- The\n`content`\n\nfield is typically omitted\n- Example: User closed the dialog, clicked outside, pressed Escape, etc.\n\n\nServers should handle each state appropriately:\n**Accept**: Process the submitted data\n**Decline**: Handle explicit decline (e.g., offer alternatives)\n**Cancel**: Handle dismissal (e.g., prompt again later)\n\n## Security Considerations\n\n- Servers\n**MUST NOT** request sensitive information through elicitation\n- Clients\n**SHOULD** implement user approval controls\n- Both parties\n**SHOULD** validate elicitation content against the provided schema\n- Clients\n**SHOULD** provide clear indication of which server is requesting information\n- Clients\n**SHOULD** allow users to decline elicitation requests at any time\n- Clients\n**SHOULD** implement rate limiting\n- Clients\n**SHOULD** present elicitation requests in a way that makes it clear what information is being requested and why",
    "metadata": {
      "title": "Elicitation - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation",
      "extracted_at": "2025-08-04T09:55:09.008610+00:00"
    },
    "word_count": 562,
    "char_count": 4034,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:09.008648+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/tools",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) allows servers to expose tools that can be invoked by\nlanguage models. Tools enable models to interact with external systems, such as querying\ndatabases, calling APIs, or performing computations. Each tool is uniquely identified by\na name and includes metadata describing its schema.\n## User Interaction Model\n\nTools in MCP are designed to be **model-controlled**, meaning that the language model can\ndiscover and invoke tools automatically based on its contextual understanding and the\nuser’s prompts.\nHowever, implementations are free to expose tools through any interface pattern that\nsuits their needs—the protocol itself does not mandate any specific user\ninteraction model.\nFor trust & safety and security, there **SHOULD** always\nbe a human in the loop with the ability to deny tool invocations.Applications **SHOULD**:\n- Provide UI that makes clear which tools are being exposed to the AI model\n- Insert clear visual indicators when tools are invoked\n- Present confirmation prompts to the user for operations, to ensure a human is in the\nloop\n\n## Capabilities\n\nServers that support tools **MUST** declare the `tools`\n\ncapability:\n`listChanged`\n\nindicates whether the server will emit notifications when the list of\navailable tools changes.\n## Protocol Messages\n\nTo discover available tools, clients send a `tools/list`\n\nrequest. This operation supports\npagination.\n**Request:**\n**Response:**\nTo invoke a tool, clients send a `tools/call`\n\nrequest:\n**Request:**\n**Response:**\n### List Changed Notification\n\nWhen the list of available tools changes, servers that declared the `listChanged`\n\ncapability **SHOULD** send a notification:\n## Message Flow\n\n## Data Types\n\nA tool definition includes:\n`name`\n\n: Unique identifier for the tool\n`title`\n\n: Optional human-readable name of the tool for display purposes.\n`description`\n\n: Human-readable description of functionality\n`inputSchema`\n\n: JSON Schema defining expected parameters\n`outputSchema`\n\n: Optional JSON Schema defining expected output structure\n`annotations`\n\n: optional properties describing tool behavior\n\nFor trust & safety and security, clients **MUST** consider\ntool annotations to be untrusted unless they come from trusted servers.\n\nTool results may contain **structured** or **unstructured** content.\n**Unstructured** content is returned in the `content`\n\nfield of a result, and can contain multiple content items of different types:\nAll content types (text, image, audio, resource links, and embedded resources)\nsupport optional\nannotations that\nprovide metadata about audience, priority, and modification times. This is the\nsame annotation format used by resources and prompts.\n#### Text Content\n\n#### Image Content\n\nThis example demonstrates the use of an optional Annotation.\n#### Audio Content\n\n#### Resource Links\n\nA tool **MAY** return links to Resources, to provide additional context\nor data. In this case, the tool will return a URI that can be subscribed to or fetched by the client:\nResource links support the same Resource annotations as regular resources to help clients understand how to use them.\nResource links returned by tools are not guaranteed to appear in the results\nof a `resources/list`\n\nrequest.\n\n#### Embedded Resources\n\nResources **MAY** be embedded to provide additional context\nor data using a suitable URI scheme. Servers that use embedded resources **SHOULD** implement the `resources`\n\ncapability:\nEmbedded resources support the same Resource annotations as regular resources to help clients understand how to use them.\n#### Structured Content\n\n**Structured** content is returned as a JSON object in the `structuredContent`\n\nfield of a result.\nFor backwards compatibility, a tool that returns structured content SHOULD also return the serialized JSON in a TextContent block.\n#### Output Schema\n\nTools may also provide an output schema for validation of structured results.\nIf an output schema is provided:\n- Servers\n**MUST** provide structured results that conform to this schema.\n- Clients\n**SHOULD** validate structured results against this schema.\n\nExample tool with output schema:\nExample valid response for this tool:\nProviding an output schema helps clients and LLMs understand and properly handle structured tool outputs by:\n- Enabling strict schema validation of responses\n- Providing type information for better integration with programming languages\n- Guiding clients and LLMs to properly parse and utilize the returned data\n- Supporting better documentation and developer experience\n\n## Error Handling\n\nTools use two error reporting mechanisms:\n-\n**Protocol Errors**: Standard JSON-RPC errors for issues like:\n- Unknown tools\n- Invalid arguments\n- Server errors\n\n-\n**Tool Execution Errors**: Reported in tool results with `isError: true`\n\n:\n- API failures\n- Invalid input data\n- Business logic errors\n\n\nExample protocol error:\nExample tool execution error:\n## Security Considerations\n\n-\nServers\n**MUST**:\n- Validate all tool inputs\n- Implement proper access controls\n- Rate limit tool invocations\n- Sanitize tool outputs\n\n-\nClients\n**SHOULD**:\n- Prompt for user confirmation on sensitive operations\n- Show tool inputs to the user before calling the server, to avoid malicious or\naccidental data exfiltration\n- Validate tool results before passing to LLM\n- Implement timeouts for tool calls\n- Log tool usage for audit purposes",
    "metadata": {
      "title": "Tools - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/tools",
      "extracted_at": "2025-08-04T09:55:10.410653+00:00"
    },
    "word_count": 795,
    "char_count": 5408,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:10.410721+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/client/sampling",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for servers to request LLM\nsampling (“completions” or “generations”) from language models via clients. This flow\nallows clients to maintain control over model access, selection, and permissions while\nenabling servers to leverage AI capabilities—with no server API keys necessary.\nServers can request text, audio, or image-based interactions and optionally include\ncontext from MCP servers in their prompts.\n## User Interaction Model\n\nSampling in MCP allows servers to implement agentic behaviors, by enabling LLM calls to\noccur *nested* inside other MCP server features.\nImplementations are free to expose sampling through any interface pattern that suits\ntheir needs—the protocol itself does not mandate any specific user interaction\nmodel.\nFor trust & safety and security, there **SHOULD** always\nbe a human in the loop with the ability to deny sampling requests.Applications **SHOULD**:\n- Provide UI that makes it easy and intuitive to review sampling requests\n- Allow users to view and edit prompts before sending\n- Present generated responses for review before delivery\n\n## Capabilities\n\nClients that support sampling **MUST** declare the `sampling`\n\ncapability during\ninitialization:\n## Protocol Messages\n\n### Creating Messages\n\nTo request a language model generation, servers send a `sampling/createMessage`\n\nrequest:\n**Request:**\n**Response:**\n## Message Flow\n\n## Data Types\n\n### Messages\n\nSampling messages can contain:\n#### Text Content\n\n#### Image Content\n\n#### Audio Content\n\n### Model Preferences\n\nModel selection in MCP requires careful abstraction since servers and clients may use\ndifferent AI providers with distinct model offerings. A server cannot simply request a\nspecific model by name since the client may not have access to that exact model or may\nprefer to use a different provider’s equivalent model.\nTo solve this, MCP implements a preference system that combines abstract capability\npriorities with optional model hints:\n#### Capability Priorities\n\nServers express their needs through three normalized priority values (0-1):\n`costPriority`\n\n: How important is minimizing costs? Higher values prefer cheaper models.\n`speedPriority`\n\n: How important is low latency? Higher values prefer faster models.\n`intelligencePriority`\n\n: How important are advanced capabilities? Higher values prefer\nmore capable models.\n\n#### Model Hints\n\nWhile priorities help select models based on characteristics, `hints`\n\nallow servers to\nsuggest specific models or model families:\n- Hints are treated as substrings that can match model names flexibly\n- Multiple hints are evaluated in order of preference\n- Clients\n**MAY** map hints to equivalent models from different providers\n- Hints are advisory—clients make final model selection\n\nFor example:\nThe client processes these preferences to select an appropriate model from its available\noptions. For instance, if the client doesn’t have access to Claude models but has Gemini,\nit might map the sonnet hint to `gemini-1.5-pro`\n\nbased on similar capabilities.\n## Error Handling\n\nClients **SHOULD** return errors for common failure cases:\nExample error:\n## Security Considerations\n\n- Clients\n**SHOULD** implement user approval controls\n- Both parties\n**SHOULD** validate message content\n- Clients\n**SHOULD** respect model preference hints\n- Clients\n**SHOULD** implement rate limiting\n- Both parties\n**MUST** handle sensitive data appropriately",
    "metadata": {
      "title": "Sampling - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/client/sampling",
      "extracted_at": "2025-08-04T09:55:11.903575+00:00"
    },
    "word_count": 500,
    "char_count": 3492,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:11.903621+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/changelog",
    "content": "This document lists changes made to the Model Context Protocol (MCP) specification since\nthe previous revision, 2025-03-26.\n## Major changes\n\n- Remove support for JSON-RPC\n**batching**\n(PR #416)\n- Add support for structured tool output\n(PR #371)\n- Classify MCP servers as OAuth Resource Servers,\nadding protected resource metadata to discover the corresponding Authorization server.\n(PR #338)\n- Require MCP clients to implement Resource Indicators as described in RFC 8707 to prevent\nmalicious servers from obtaining access tokens.\n(PR #734)\n- Clarify security considerations and best practices\nin the authorization spec and in a new security best practices page.\n- Add support for\n**elicitation**, enabling servers to request additional\ninformation from users during interactions.\n(PR #382)\n- Add support for\n**resource links** in\ntool call results. (PR #603)\n- Require negotiated protocol version to be specified\nvia\n`MCP-Protocol-Version`\n\nheader in subsequent requests when using HTTP (PR #548).\n- Change\n**SHOULD** to **MUST** in Lifecycle Operation\n\n## Other schema changes\n\n- Add\n`_meta`\n\nfield to additional interface types (PR #710),\nand specify proper usage.\n- Add\n`context`\n\nfield to `CompletionRequest`\n\n, providing for completion requests to include\npreviously-resolved variables (PR #598).\n- Add\n`title`\n\nfield for human-friendly display names, so that `name`\n\ncan be used as a programmatic\nidentifier (PR #663)\n\n## Full changelog\n\nFor a complete list of all changes that have been made since the last protocol revision,\nsee GitHub.",
    "metadata": {
      "title": "Key Changes - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/changelog",
      "extracted_at": "2025-08-04T09:55:13.707678+00:00"
    },
    "word_count": 231,
    "char_count": 1546,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:13.707698+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/security_best_practices",
    "content": "## Introduction\n\n### Purpose and Scope\n\nThis document provides security considerations for the Model Context Protocol (MCP), complementing the MCP Authorization specification. This document identifies security risks, attack vectors, and best practices specific to MCP implementations.\nThe primary audience for this document includes developers implementing MCP authorization flows, MCP server operators, and security professionals evaluating MCP-based systems. This document should be read alongside the MCP Authorization specification and OAuth 2.0 security best practices.\n## Attacks and Mitigations\n\nThis section gives a detailed description of attacks on MCP implementations, along with potential countermeasures.\n### Confused Deputy Problem\n\nAttackers can exploit MCP servers proxying other resource servers, creating “confused deputy” vulnerabilities.\n#### Terminology\n\n**MCP Proxy Server**\n: An MCP server that connects MCP clients to third-party APIs, offering MCP features while delegating operations and acting as a single OAuth client to the third-party API server.\n**Third-Party Authorization Server**\n: Authorization server that protects the third-party API. It may lack dynamic client registration support, requiring MCP proxy to use a static client ID for all requests.\n**Third-Party API**\n: The protected resource server that provides the actual API functionality. Access to this\nAPI requires tokens issued by the third-party authorization server.\n**Static Client ID**\n: A fixed OAuth 2.0 client identifier used by the MCP proxy server when communicating with\nthe third-party authorization server. This Client ID refers to the MCP server acting as a client\nto the Third-Party API. It is the same value for all MCP server to Third-Party API interactions regardless of\nwhich MCP client initiated the request.\n#### Architecture and Attack Flows\n\n##### Normal OAuth proxy usage (preserves user consent)\n\n##### Malicious OAuth proxy usage (skips user consent)\n\n#### Attack Description\n\nWhen an MCP proxy server uses a static client ID to authenticate with a third-party\nauthorization server that does not support dynamic client registration, the following\nattack becomes possible:\n- A user authenticates normally through the MCP proxy server to access the third-party API\n- During this flow, the third-party authorization server sets a cookie on the user agent\nindicating consent for the static client ID\n- An attacker later sends the user a malicious link containing a crafted authorization request which contains a malicious redirect URI along with a new dynamically registered client ID\n- When the user clicks the link, their browser still has the consent cookie from the previous legitimate request\n- The third-party authorization server detects the cookie and skips the consent screen\n- The MCP authorization code is redirected to the attacker’s server (specified in the crafted redirect_uri during dynamic client registration)\n- The attacker exchanges the stolen authorization code for access tokens for the MCP server without the user’s explicit approval\n- Attacker now has access to the third-party API as the compromised user\n\n#### Mitigation\n\nMCP proxy servers using static client IDs **MUST** obtain user consent for each dynamically\nregistered client before forwarding to third-party authorization servers (which may require additional consent).\n### Token Passthrough\n\n“Token passthrough” is an anti-pattern where an MCP server accepts tokens from an MCP client without validating that the tokens were properly issued *to the MCP server* and “passing them through” to the downstream API.\n#### Risks\n\nToken passthrough is explicitly forbidden in the authorization specification as it introduces a number of security risks, that include:\n**Security Control Circumvention**\n- The MCP Server or downstream APIs might implement important security controls like rate limiting, request validation, or traffic monitoring, that depend on the token audience or other credential constraints. If clients can obtain and use tokens directly with the downstream APIs without the MCP server validating them properly or ensuring that the tokens are issued for the right service, they bypass these controls.\n\n**Accountability and Audit Trail Issues**\n- The MCP Server will be unable to identify or distinguish between MCP Clients when clients are calling with an upstream-issued access token which may be opaque to the MCP Server.\n- The downstream Resource Server’s logs may show requests that appear to come from a different source with a different identity, rather than the MCP server that is actually forwarding the tokens.\n- Both factors make incident investigation, controls, and auditing more difficult.\n- If the MCP Server passes tokens without validating their claims (e.g., roles, privileges, or audience) or other metadata, a malicious actor in possession of a stolen token can use the server as a proxy for data exfiltration.\n\n**Trust Boundary Issues**\n- The downstream Resource Server grants trust to specific entities. This trust might include assumptions about origin or client behavior patterns. Breaking this trust boundary could lead to unexpected issues.\n- If the token is accepted by multiple services without proper validation, an attacker compromising one service can use the token to access other connected services.\n\n**Future Compatibility Risk**\n- Even if an MCP Server starts as a “pure proxy” today, it might need to add security controls later. Starting with proper token audience separation makes it easier to evolve the security model.\n\n\n#### Mitigation\n\nMCP servers **MUST NOT** accept any tokens that were not explicitly issued for the MCP server.\n### Session Hijacking\n\nSession hijacking is an attack vector where a client is provided a session ID by the server, and an unauthorized party is able to obtain and use that same session ID to impersonate the original client and perform unauthorized actions on their behalf.\n#### Session Hijack Prompt Injection\n\n#### Session Hijack Impersonation\n\n#### Attack Description\n\nWhen you have multiple stateful HTTP servers that handle MCP requests, the following attack vectors are possible:\n**Session Hijack Prompt Injection**\n-\nThe client connects to\n**Server A** and receives a session ID.\n-\nThe attacker obtains an existing session ID and sends a malicious event to\n**Server B** with said session ID.\n- When a server supports redelivery/resumable streams, deliberately terminating the request before receiving the response could lead to it being resumed by the original client via the GET request for server sent events.\n- If a particular server initiates server sent events as a consequence of a tool call such as a\n`notifications/tools/list_changed`\n\n, where it is possible to affect the tools that are offered by the server, a client could end up with tools that they were not aware were enabled.\n\n-\n**Server B** enqueues the event (associated with session ID) into a shared queue.\n-\n**Server A** polls the queue for events using the session ID and retrieves the malicious payload.\n-\n**Server A** sends the malicious payload to the client as an asynchronous or resumed response.\n-\nThe client receives and acts on the malicious payload, leading to potential compromise.\n\n**Session Hijack Impersonation**\n- The MCP client authenticates with the MCP server, creating a persistent session ID.\n- The attacker obtains the session ID.\n- The attacker makes calls to the MCP server using the session ID.\n- MCP server does not check for additional authorization and treats the attacker as a legitimate user, allowing unauthorized access or actions.\n\n#### Mitigation\n\nTo prevent session hijacking and event injection attacks, the following mitigations should be implemented:\nMCP servers that implement authorization **MUST** verify all inbound requests.\nMCP Servers **MUST NOT** use sessions for authentication.\nMCP servers **MUST** use secure, non-deterministic session IDs.\nGenerated session IDs (e.g., UUIDs) **SHOULD** use secure random number generators. Avoid predictable or sequential session identifiers that could be guessed by an attacker. Rotating or expiring session IDs can also reduce the risk.\nMCP servers **SHOULD** bind session IDs to user-specific information.\nWhen storing or transmitting session-related data (e.g., in a queue), combine the session ID with information unique to the authorized user, such as their internal user ID. Use a key format like `<user_id>:<session_id>`\n\n. This ensures that even if an attacker guesses a session ID, they cannot impersonate another user as the user ID is derived from the user token and not provided by the client.\nMCP servers can optionally leverage additional unique identifiers.",
    "metadata": {
      "title": "Security Best Practices - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/security_best_practices",
      "extracted_at": "2025-08-04T09:55:15.173709+00:00"
    },
    "word_count": 1320,
    "char_count": 8717,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:15.173788+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/client",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for clients to expose\nfilesystem “roots” to servers. Roots define the boundaries of where servers can operate\nwithin the filesystem, allowing them to understand which directories and files they have\naccess to. Servers can request the list of roots from supporting clients and receive\nnotifications when that list changes.\n## User Interaction Model\n\nRoots in MCP are typically exposed through workspace or project configuration interfaces.\nFor example, implementations could offer a workspace/project picker that allows users to\nselect directories and files the server should have access to. This can be combined with\nautomatic workspace detection from version control systems or project files.\nHowever, implementations are free to expose roots through any interface pattern that\nsuits their needs—the protocol itself does not mandate any specific user\ninteraction model.\n## Capabilities\n\nClients that support roots **MUST** declare the `roots`\n\ncapability during\ninitialization:\n`listChanged`\n\nindicates whether the client will emit notifications when the list of roots\nchanges.\n## Protocol Messages\n\n### Listing Roots\n\nTo retrieve roots, servers send a `roots/list`\n\nrequest:\n**Request:**\n**Response:**\n### Root List Changes\n\nWhen roots change, clients that support `listChanged`\n\n**MUST** send a notification:\n## Message Flow\n\n## Data Types\n\n### Root\n\nA root definition includes:\n`uri`\n\n: Unique identifier for the root. This **MUST** be a `file://`\n\nURI in the current\nspecification.\n`name`\n\n: Optional human-readable name for display purposes.\n\nExample roots for different use cases:\n#### Project Directory\n\n#### Multiple Repositories\n\n## Error Handling\n\nClients **SHOULD** return standard JSON-RPC errors for common failure cases:\n- Client does not support roots:\n`-32601`\n\n(Method not found)\n- Internal errors:\n`-32603`\n\n\nExample error:\n## Security Considerations\n\n-\nClients\n**MUST**:\n- Only expose roots with appropriate permissions\n- Validate all root URIs to prevent path traversal\n- Implement proper access controls\n- Monitor root accessibility\n\n-\nServers\n**SHOULD**:\n- Handle cases where roots become unavailable\n- Respect root boundaries during operations\n- Validate all paths against provided roots\n\n\n## Implementation Guidelines\n\n-\nClients\n**SHOULD**:\n- Prompt users for consent before exposing roots to servers\n- Provide clear user interfaces for root management\n- Validate root accessibility before exposing\n- Monitor for root changes\n\n-\nServers\n**SHOULD**:\n- Check for roots capability before usage\n- Handle root list changes gracefully\n- Respect root boundaries in operations\n- Cache root information appropriately",
    "metadata": {
      "title": "Roots - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/client",
      "extracted_at": "2025-08-04T09:55:16.994662+00:00"
    },
    "word_count": 391,
    "char_count": 2728,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:16.994690+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/resources",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for servers to expose\nresources to clients. Resources allow servers to share data that provides context to\nlanguage models, such as files, database schemas, or application-specific information.\nEach resource is uniquely identified by a\nURI.\n## User Interaction Model\n\nResources in MCP are designed to be **application-driven**, with host applications\ndetermining how to incorporate context based on their needs.\nFor example, applications could:\n- Expose resources through UI elements for explicit selection, in a tree or list view\n- Allow the user to search through and filter available resources\n- Implement automatic context inclusion, based on heuristics or the AI model’s selection\n\nHowever, implementations are free to expose resources through any interface pattern that\nsuits their needs—the protocol itself does not mandate any specific user\ninteraction model.\n## Capabilities\n\nServers that support resources **MUST** declare the `resources`\n\ncapability:\nThe capability supports two optional features:\n`subscribe`\n\n: whether the client can subscribe to be notified of changes to individual\nresources.\n`listChanged`\n\n: whether the server will emit notifications when the list of available\nresources changes.\n\nBoth `subscribe`\n\nand `listChanged`\n\nare optional—servers can support neither,\neither, or both:\n## Protocol Messages\n\n### Listing Resources\n\nTo discover available resources, clients send a `resources/list`\n\nrequest. This operation\nsupports pagination.\n**Request:**\n**Response:**\n### Reading Resources\n\nTo retrieve resource contents, clients send a `resources/read`\n\nrequest:\n**Request:**\n**Response:**\n### Resource Templates\n\nResource templates allow servers to expose parameterized resources using\nURI templates. Arguments may be\nauto-completed through the completion API.\n**Request:**\n**Response:**\n### List Changed Notification\n\nWhen the list of available resources changes, servers that declared the `listChanged`\n\ncapability **SHOULD** send a notification:\n### Subscriptions\n\nThe protocol supports optional subscriptions to resource changes. Clients can subscribe\nto specific resources and receive notifications when they change:\n**Subscribe Request:**\n**Update Notification:**\n## Message Flow\n\n## Data Types\n\n### Resource\n\nA resource definition includes:\n`uri`\n\n: Unique identifier for the resource\n`name`\n\n: The name of the resource.\n`title`\n\n: Optional human-readable name of the resource for display purposes.\n`description`\n\n: Optional description\n`mimeType`\n\n: Optional MIME type\n`size`\n\n: Optional size in bytes\n\n### Resource Contents\n\nResources can contain either text or binary data:\n#### Text Content\n\n#### Binary Content\n\n### Annotations\n\nResources, resource templates and content blocks support optional annotations that provide hints to clients about how to use or display the resource:\n`audience`\n\n: An array indicating the intended audience(s) for this resource. Valid values are `\"user\"`\n\nand `\"assistant\"`\n\n. For example, `[\"user\", \"assistant\"]`\n\nindicates content useful for both.\n`priority`\n\n: A number from 0.0 to 1.0 indicating the importance of this resource. A value of 1 means “most important” (effectively required), while 0 means “least important” (entirely optional).\n`lastModified`\n\n: An ISO 8601 formatted timestamp indicating when the resource was last modified (e.g., `\"2025-01-12T15:00:58Z\"`\n\n).\n\nExample resource with annotations:\nClients can use these annotations to:\n- Filter resources based on their intended audience\n- Prioritize which resources to include in context\n- Display modification times or sort by recency\n\n## Common URI Schemes\n\nThe protocol defines several standard URI schemes. This list not\nexhaustive—implementations are always free to use additional, custom URI schemes.\n### https://\n\nUsed to represent a resource available on the web.\nServers **SHOULD** use this scheme only when the client is able to fetch and load the\nresource directly from the web on its own—that is, it doesn’t need to read the resource\nvia the MCP server.\nFor other use cases, servers **SHOULD** prefer to use another URI scheme, or define a\ncustom one, even if the server will itself be downloading resource contents over the\ninternet.\n### file://\n\nUsed to identify resources that behave like a filesystem. However, the resources do not\nneed to map to an actual physical filesystem.\nMCP servers **MAY** identify file:// resources with an\nXDG MIME type,\nlike `inode/directory`\n\n, to represent non-regular files (such as directories) that don’t\notherwise have a standard MIME type.\n### git://\n\nGit version control integration.\n### Custom URI Schemes\n\nCustom URI schemes **MUST** be in accordance with RFC3986,\ntaking the above guidance in to account.\n## Error Handling\n\nServers **SHOULD** return standard JSON-RPC errors for common failure cases:\n- Resource not found:\n`-32002`\n\n- Internal errors:\n`-32603`\n\n\nExample error:\n## Security Considerations\n\n- Servers\n**MUST** validate all resource URIs\n- Access controls\n**SHOULD** be implemented for sensitive resources\n- Binary data\n**MUST** be properly encoded\n- Resource permissions\n**SHOULD** be checked before operations",
    "metadata": {
      "title": "Resources - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/resources",
      "extracted_at": "2025-08-04T09:55:18.320094+00:00"
    },
    "word_count": 743,
    "char_count": 5212,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:18.320140+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/authorization",
    "content": "**Protocol Revision**: 2025-06-18\n\n## Introduction\n\n### Purpose and Scope\n\nThe Model Context Protocol provides authorization capabilities at the transport level,\nenabling MCP clients to make requests to restricted MCP servers on behalf of resource\nowners. This specification defines the authorization flow for HTTP-based transports.\n### Protocol Requirements\n\nAuthorization is **OPTIONAL** for MCP implementations. When supported:\n- Implementations using an HTTP-based transport\n**SHOULD** conform to this specification.\n- Implementations using an STDIO transport\n**SHOULD NOT** follow this specification, and\ninstead retrieve credentials from the environment.\n- Implementations using alternative transports\n**MUST** follow established security best\npractices for their protocol.\n\n### Standards Compliance\n\nThis authorization mechanism is based on established specifications listed below, but\nimplements a selected subset of their features to ensure security and interoperability\nwhile maintaining simplicity:\n## Authorization Flow\n\n### Roles\n\nA protected *MCP server* acts as an OAuth 2.1 resource server,\ncapable of accepting and responding to protected resource requests using access tokens.\nAn *MCP client* acts as an OAuth 2.1 client,\nmaking protected resource requests on behalf of a resource owner.\nThe *authorization server* is responsible for interacting with the user (if necessary) and issuing access tokens for use at the MCP server.\nThe implementation details of the authorization server are beyond the scope of this specification. It may be hosted with the\nresource server or a separate entity. The Authorization Server Discovery section\nspecifies how an MCP server indicates the location of its corresponding authorization server to a client.\n### Overview\n\n-\nAuthorization servers\n**MUST** implement OAuth 2.1 with appropriate security\nmeasures for both confidential and public clients.\n-\nAuthorization servers and MCP clients\n**SHOULD** support the OAuth 2.0 Dynamic Client Registration\nProtocol (RFC7591).\n-\nMCP servers\n**MUST** implement OAuth 2.0 Protected Resource Metadata (RFC9728).\nMCP clients **MUST** use OAuth 2.0 Protected Resource Metadata for authorization server discovery.\n-\nAuthorization servers\n**MUST** provide OAuth 2.0 Authorization\nServer Metadata (RFC8414).\nMCP clients **MUST** use the OAuth 2.0 Authorization Server Metadata.\n\n### Authorization Server Discovery\n\nThis section describes the mechanisms by which MCP servers advertise their associated\nauthorization servers to MCP clients, as well as the discovery process through which MCP\nclients can determine authorization server endpoints and supported capabilities.\n#### Authorization Server Location\n\nMCP servers **MUST** implement the OAuth 2.0 Protected Resource Metadata (RFC9728)\nspecification to indicate the locations of authorization servers. The Protected Resource Metadata document returned by the MCP server **MUST** include\nthe `authorization_servers`\n\nfield containing at least one authorization server.\nThe specific use of `authorization_servers`\n\nis beyond the scope of this specification; implementers should consult\nOAuth 2.0 Protected Resource Metadata (RFC9728) for\nguidance on implementation details.\nImplementors should note that Protected Resource Metadata documents can define multiple authorization servers. The responsibility for selecting which authorization server to use lies with the MCP client, following the guidelines specified in\nRFC9728 Section 7.6 “Authorization Servers”.\nMCP servers **MUST** use the HTTP header `WWW-Authenticate`\n\nwhen returning a *401 Unauthorized* to indicate the location of the resource server metadata URL\nas described in RFC9728 Section 5.1 “WWW-Authenticate Response”.\nMCP clients **MUST** be able to parse `WWW-Authenticate`\n\nheaders and respond appropriately to `HTTP 401 Unauthorized`\n\nresponses from the MCP server.\nMCP clients **MUST** follow the OAuth 2.0 Authorization Server Metadata RFC8414\nspecification to obtain the information required to interact with the authorization server.\n#### Sequence Diagram\n\nThe following diagram outlines an example flow:\n### Dynamic Client Registration\n\nMCP clients and authorization servers **SHOULD** support the\nOAuth 2.0 Dynamic Client Registration Protocol RFC7591\nto allow MCP clients to obtain OAuth client IDs without user interaction. This provides a\nstandardized way for clients to automatically register with new authorization servers, which is crucial\nfor MCP because:\n- Clients may not know all possible MCP servers and their authorization servers in advance.\n- Manual registration would create friction for users.\n- It enables seamless connection to new MCP servers and their authorization servers.\n- Authorization servers can implement their own registration policies.\n\nAny authorization servers that *do not* support Dynamic Client Registration need to provide\nalternative ways to obtain a client ID (and, if applicable, client credentials). For one of\nthese authorization servers, MCP clients will have to either:\n- Hardcode a client ID (and, if applicable, client credentials) specifically for the MCP client to use when\ninteracting with that authorization server, or\n- Present a UI to users that allows them to enter these details, after registering an\nOAuth client themselves (e.g., through a configuration interface hosted by the\nserver).\n\n### Authorization Flow Steps\n\nThe complete Authorization flow proceeds as follows:\n#### Resource Parameter Implementation\n\nMCP clients **MUST** implement Resource Indicators for OAuth 2.0 as defined in RFC 8707\nto explicitly specify the target resource for which the token is being requested. The `resource`\n\nparameter:\n**MUST** be included in both authorization requests and token requests.\n**MUST** identify the MCP server that the client intends to use the token with.\n**MUST** use the canonical URI of the MCP server as defined in RFC 8707 Section 2.\n\n##### Canonical Server URI\n\nFor the purposes of this specification, the canonical URI of an MCP server is defined as the resource identifier as specified in\nRFC 8707 Section 2 and aligns with the `resource`\n\nparameter in\nRFC 9728.\nMCP clients **SHOULD** provide the most specific URI that they can for the MCP server they intend to access, following the guidance in RFC 8707. While the canonical form uses lowercase scheme and host components, implementations **SHOULD** accept uppercase scheme and host components for robustness and interoperability.\nExamples of valid canonical URIs:\n`https://mcp.example.com/mcp`\n\n`https://mcp.example.com`\n\n`https://mcp.example.com:8443`\n\n`https://mcp.example.com/server/mcp`\n\n(when path component is necessary to identify individual MCP server)\n\nExamples of invalid canonical URIs:\n`mcp.example.com`\n\n(missing scheme)\n`https://mcp.example.com#fragment`\n\n(contains fragment)\n\n**Note:** While both `https://mcp.example.com/`\n\n(with trailing slash) and `https://mcp.example.com`\n\n(without trailing slash) are technically valid absolute URIs according to RFC 3986, implementations **SHOULD** consistently use the form without the trailing slash for better interoperability unless the trailing slash is semantically significant for the specific resource.\n\nFor example, if accessing an MCP server at `https://mcp.example.com`\n\n, the authorization request would include:\nMCP clients **MUST** send this parameter regardless of whether authorization servers support it.\n### Access Token Usage\n\n#### Token Requirements\n\nAccess token handling when making requests to MCP servers **MUST** conform to the requirements defined in\nOAuth 2.1 Section 5 “Resource Requests”.\nSpecifically:\n- MCP client\n**MUST** use the Authorization request header field defined in\nOAuth 2.1 Section 5.1.1:\n\nNote that authorization **MUST** be included in every HTTP request from client to server,\neven if they are part of the same logical session.\n- Access tokens\n**MUST NOT** be included in the URI query string\n\nExample request:\n#### Token Handling\n\nMCP servers, acting in their role as an OAuth 2.1 resource server, **MUST** validate access tokens as described in\nOAuth 2.1 Section 5.2.\nMCP servers **MUST** validate that access tokens were issued specifically for them as the intended audience,\naccording to RFC 8707 Section 2.\nIf validation fails, servers **MUST** respond according to\nOAuth 2.1 Section 5.3\nerror handling requirements. Invalid or expired tokens **MUST** receive a HTTP 401\nresponse.\nMCP clients **MUST NOT** send tokens to the MCP server other than ones issued by the MCP server’s authorization server.\nAuthorization servers **MUST** only accept tokens that are valid for use with their\nown resources.\nMCP servers **MUST NOT** accept or transit any other tokens.\n### Error Handling\n\nServers **MUST** return appropriate HTTP status codes for authorization errors:\n| Status Code | Description | Usage |\n|---|\n| 401 | Unauthorized | Authorization required or token invalid |\n| 403 | Forbidden | Invalid scopes or insufficient permissions |\n| 400 | Bad Request | Malformed authorization request |\n\n## Security Considerations\n\nImplementations **MUST** follow OAuth 2.1 security best practices as laid out in OAuth 2.1 Section 7. “Security Considerations”.\n### Token Audience Binding and Validation\n\nRFC 8707 Resource Indicators provide critical security benefits by binding tokens to their intended\naudiences **when the Authorization Server supports the capability**. To enable current and future adoption:\n- MCP clients\n**MUST** include the `resource`\n\nparameter in authorization and token requests as specified in the Resource Parameter Implementation section\n- MCP servers\n**MUST** validate that tokens presented to them were specifically issued for their use\n\nThe Security Best Practices document\noutlines why token audience validation is crucial and why token passthrough is explicitly forbidden.\n### Token Theft\n\nAttackers who obtain tokens stored by the client, or tokens cached or logged on the server can access protected resources with\nrequests that appear legitimate to resource servers.\nClients and servers **MUST** implement secure token storage and follow OAuth best practices,\nas outlined in OAuth 2.1, Section 7.1.\nAuthorization servers **SHOULD** issue short-lived access tokens to reduce the impact of leaked tokens.\nFor public clients, authorization servers **MUST** rotate refresh tokens as described in OAuth 2.1 Section 4.3.1 “Token Endpoint Extension”.\n### Communication Security\n\nImplementations **MUST** follow OAuth 2.1 Section 1.5 “Communication Security”.\nSpecifically:\n- All authorization server endpoints\n**MUST** be served over HTTPS.\n- All redirect URIs\n**MUST** be either `localhost`\n\nor use HTTPS.\n\n### Authorization Code Protection\n\nAn attacker who has gained access to an authorization code contained in an authorization response can try to redeem the authorization code for an access token or otherwise make use of the authorization code.\n(Further described in OAuth 2.1 Section 7.5)\nTo mitigate this, MCP clients **MUST** implement PKCE according to OAuth 2.1 Section 7.5.2.\nPKCE helps prevent authorization code interception and injection attacks by requiring clients to create a secret verifier-challenge pair, ensuring that only the original requestor can exchange an authorization code for tokens.\n### Open Redirection\n\nAn attacker may craft malicious redirect URIs to direct users to phishing sites.\nMCP clients **MUST** have redirect URIs registered with the authorization server.\nAuthorization servers **MUST** validate exact redirect URIs against pre-registered values to prevent redirection attacks.\nMCP clients **SHOULD** use and verify state parameters in the authorization code flow\nand discard any results that do not include or have a mismatch with the original state.\nAuthorization servers **MUST** take precautions to prevent redirecting user agents to untrusted URI’s, following suggestions laid out in OAuth 2.1 Section 7.12.2\nAuthorization servers **SHOULD** only automatically redirect the user agent if it trusts the redirection URI. If the URI is not trusted, the authorization server MAY inform the user and rely on the user to make the correct decision.\n### Confused Deputy Problem\n\nAttackers can exploit MCP servers acting as intermediaries to third-party APIs, leading to confused deputy vulnerabilities.\nBy using stolen authorization codes, they can obtain access tokens without user consent.\nMCP proxy servers using static client IDs **MUST** obtain user consent for each dynamically\nregistered client before forwarding to third-party authorization servers (which may require additional consent).\n### Access Token Privilege Restriction\n\nAn attacker can gain unauthorized access or otherwise compromise a MCP server if the server accepts tokens issued for other resources.\nThis vulnerability has two critical dimensions:\n**Audience validation failures.** When an MCP server doesn’t verify that tokens were specifically intended for it (for example, via the audience claim, as mentioned in RFC9068), it may accept tokens originally issued for other services. This breaks a fundamental OAuth security boundary, allowing attackers to reuse legitimate tokens across different services than intended.\n**Token passthrough.** If the MCP server not only accepts tokens with incorrect audiences but also forwards these unmodified tokens to downstream services, it can potentially cause the “confused deputy” problem, where the downstream API may incorrectly trust the token as if it came from the MCP server or assume the token was validated by the upstream API. See the Token Passthrough section of the Security Best Practices guide for additional details.\n\nMCP servers **MUST** validate access tokens before processing the request, ensuring the access token is issued specifically for the MCP server, and take all necessary steps to ensure no data is returned to unauthorized parties.\nA MCP server **MUST** follow the guidelines in OAuth 2.1 - Section 5.2 to validate inbound tokens.\nMCP servers **MUST** only accept tokens specifically intended for themselves and **MUST** reject tokens that do not include them in the audience claim or otherwise verify that they are the intended recipient of the token. See the Security Best Practices Token Passthrough section for details.\nIf the MCP server makes requests to upstream APIs, it may act as an OAuth client to them. The access token used at the upstream API is a seperate token, issued by the upstream authorization server. The MCP server **MUST NOT** pass through the token it received from the MCP client.\nMCP clients **MUST** implement and use the `resource`\n\nparameter as defined in RFC 8707 - Resource Indicators for OAuth 2.0\nto explicitly specify the target resource for which the token is being requested. This requirement aligns with the recommendation in\nRFC 9728 Section 7.4. This ensures that access tokens are bound to their intended resources and\ncannot be misused across different services.",
    "metadata": {
      "title": "Authorization - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/authorization",
      "extracted_at": "2025-08-04T09:55:20.061542+00:00"
    },
    "word_count": 2144,
    "char_count": 14950,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:20.061654+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/schema",
    "content": "`Annotations`\n\nOptional annotations for the client. The client can use annotations to inform how objects are used or displayed\n\nDescribes who the intended customer of this object or data is.\n\nIt can include multiple entries to indicate content useful for multiple audiences (e.g., `[“user”, “assistant”]`\n\n).\n\nThe moment the resource was last modified, as an ISO 8601 formatted string.\n\nShould be an ISO 8601 formatted string (e.g., “2025-01-12T15:00:58Z”).\n\nExamples: last activity timestamp in an open file, timestamp when the resource was attached, etc.\n\nDescribes how important this data is for operating the server.\n\nA value of 1 means “most important,” and indicates that the data is effectively required, while 0 means “least important,” and indicates that the data is entirely optional.\n\n`AudioContent`\n\nAudio provided to or from an LLM.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nOptional annotations for the client.\n\nThe base64-encoded audio data.\n\nThe MIME type of the audio. Different providers may support different audio types.\n\n`BlobResourceContents`\n\nThe contents of a specific resource or sub-resource.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nA base64-encoded string representing the binary data of the item.\n\nThe MIME type of this resource, if known.\n\nThe URI of this resource.\n\n`BooleanSchema`\n\n`ClientCapabilities`\n\nCapabilities a client may support. Known capabilities are defined here, in this schema, but this is not a closed set: any client can define its own, additional capabilities.\n\nPresent if the client supports elicitation from the server.\n\nExperimental, non-standard capabilities that the client supports.\n\nPresent if the client supports listing roots.\n\n`Optional`\n\nlistChanged?: booleanWhether the client supports notifications for changes to the roots list.\n\nPresent if the client supports sampling from an LLM.\n\n`ContentBlock`\n\n`Cursor`\n\nAn opaque token used to represent a cursor for pagination.\n\n`EmbeddedResource`\n\nThe contents of a resource, embedded into a prompt or tool call result.\n\nIt is up to the client how best to render embedded resources for the benefit of the LLM and/or the user.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nOptional annotations for the client.\n\n`EmptyResult`\n\nA response that indicates success but carries no data.\n\n`EnumSchema`\n\n`ImageContent`\n\nAn image provided to or from an LLM.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nOptional annotations for the client.\n\nThe base64-encoded image data.\n\nThe MIME type of the image. Different providers may support different image types.\n\n`Implementation`\n\nDescribes the name and version of an MCP implementation, with an optional title for UI representation.\n\nIntended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn’t present).\n\nIntended for UI and end-user contexts — optimized to be human-readable and easily understood, even by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title`\n\nshould be given precedence over using `name`\n\n,\nif present).\n\n`JSONRPCError`\n\nA response to a request that indicates an error occurred.\n\nThe error type that occurred.\n\n`Optional`\n\ndata?: unknownAdditional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).\n\nA short description of the error. The message SHOULD be limited to a concise single sentence.\n\n`JSONRPCNotification`\n\nA notification which does not expect a response.\n\n`Optional`\n\n_meta?: { [key: string]: unknown }See [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\n`JSONRPCRequest`\n\nA request that expects a response.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nIf specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\n\n`JSONRPCResponse`\n\nA successful (non-error) response to a request.\n\n`LoggingLevel`\n\nThe severity of a log message.\n\nThese map to syslog message severities, as specified in RFC-5424: https://datatracker.ietf.org/doc/html/rfc5424#section-6.2.1\n\n`ModelHint`\n\nHints to use for model selection.\n\nKeys not declared here are currently left unspecified by the spec and are up to the client to interpret.\n\nA hint for a model name.\n\nThe client SHOULD treat this as a substring of a model name; for example:\n\n`claude-3-5-sonnet`\n\nshould match `claude-3-5-sonnet-20241022`\n\n`sonnet`\n\nshould match `claude-3-5-sonnet-20241022`\n\n, `claude-3-sonnet-20240229`\n\n, etc.`claude`\n\nshould match any Claude modelThe client MAY also map the string to a different provider’s model name or a different model family, as long as it fills a similar niche; for example:\n\n`gemini-1.5-flash`\n\ncould match `claude-3-haiku-20240307`\n\n`ModelPreferences`\n\nThe server’s preferences for model selection, requested of the client during sampling.\n\nBecause LLMs can vary along multiple dimensions, choosing the “best” model is rarely straightforward. Different models excel in different areas—some are faster but less capable, others are more capable but more expensive, and so on. This interface allows servers to express their priorities across multiple dimensions to help clients make an appropriate selection for their use case.\n\nThese preferences are always advisory. The client MAY ignore them. It is also up to the client to decide how to interpret these preferences and how to balance them against other considerations.\n\nHow much to prioritize cost when selecting a model. A value of 0 means cost is not important, while a value of 1 means cost is the most important factor.\n\nOptional hints to use for model selection.\n\nIf multiple hints are specified, the client MUST evaluate them in order (such that the first match is taken).\n\nThe client SHOULD prioritize these hints over the numeric priorities, but MAY still use the priorities to select from ambiguous matches.\n\nHow much to prioritize intelligence and capabilities when selecting a model. A value of 0 means intelligence is not important, while a value of 1 means intelligence is the most important factor.\n\nHow much to prioritize sampling speed (latency) when selecting a model. A value of 0 means speed is not important, while a value of 1 means speed is the most important factor.\n\n`NumberSchema`\n\n`PrimitiveSchemaDefinition`\n\nRestricted schema definitions that only allow primitive types without nested objects or arrays.\n\n`ProgressToken`\n\nA progress token, used to associate progress notifications with the original request.\n\n`Prompt`\n\nA prompt or prompt template that the server offers.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nA list of arguments to use for templating the prompt.\n\nAn optional description of what this prompt provides\n\nIntended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn’t present).\n\nIntended for UI and end-user contexts — optimized to be human-readable and easily understood, even by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title`\n\nshould be given precedence over using `name`\n\n,\nif present).\n\n`PromptArgument`\n\nDescribes an argument that a prompt can accept.\n\nA human-readable description of the argument.\n\nIntended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn’t present).\n\nWhether this argument must be provided.\n\nIntended for UI and end-user contexts — optimized to be human-readable and easily understood, even by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title`\n\nshould be given precedence over using `name`\n\n,\nif present).\n\n`PromptMessage`\n\nDescribes a message returned as part of a prompt.\n\nThis is similar to `SamplingMessage`\n\n, but also supports the embedding of\nresources from the MCP server.\n\n`PromptReference`\n\nIdentifies a prompt.\n\nIntended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn’t present).\n\nIntended for UI and end-user contexts — optimized to be human-readable and easily understood, even by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title`\n\nshould be given precedence over using `name`\n\n,\nif present).\n\n`RequestId`\n\nA uniquely identifying ID for a request in JSON-RPC.\n\n`Resource`\n\nA known resource that the server is capable of reading.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nOptional annotations for the client.\n\nA description of what this resource represents.\n\nThis can be used by clients to improve the LLM’s understanding of available resources. It can be thought of like a “hint” to the model.\n\nThe MIME type of this resource, if known.\n\nIntended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn’t present).\n\nThe size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.\n\nThis can be used by Hosts to display file sizes and estimate context window usage.\n\nIntended for UI and end-user contexts — optimized to be human-readable and easily understood, even by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title`\n\nshould be given precedence over using `name`\n\n,\nif present).\n\nThe URI of this resource.\n\n`ResourceContents`\n\nThe contents of a specific resource or sub-resource.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nThe MIME type of this resource, if known.\n\nThe URI of this resource.\n\n`ResourceLink`\n\nA resource that the server is capable of reading, included in a prompt or tool call result.\n\nNote: resource links returned by tools are not guaranteed to appear in the results of `resources/list`\n\nrequests.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nOptional annotations for the client.\n\nA description of what this resource represents.\n\nThis can be used by clients to improve the LLM’s understanding of available resources. It can be thought of like a “hint” to the model.\n\nThe MIME type of this resource, if known.\n\nIntended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn’t present).\n\nThe size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.\n\nThis can be used by Hosts to display file sizes and estimate context window usage.\n\nIntended for UI and end-user contexts — optimized to be human-readable and easily understood, even by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title`\n\nshould be given precedence over using `name`\n\n,\nif present).\n\nThe URI of this resource.\n\n`ResourceTemplate`\n\nA template description for resources available on the server.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nOptional annotations for the client.\n\nA description of what this template is for.\n\nThis can be used by clients to improve the LLM’s understanding of available resources. It can be thought of like a “hint” to the model.\n\nThe MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.\n\nIntended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn’t present).\n\nIntended for UI and end-user contexts — optimized to be human-readable and easily understood, even by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title`\n\nshould be given precedence over using `name`\n\n,\nif present).\n\nA URI template (according to RFC 6570) that can be used to construct resource URIs.\n\n`ResourceTemplateReference`\n\nA reference to a resource or resource template definition.\n\nThe URI or URI template of the resource.\n\n`Result`\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\n`Role`\n\nThe sender or recipient of messages and data in a conversation.\n\n`Root`\n\nRepresents a root directory or file that the server can operate on.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nAn optional name for the root. This can be used to provide a human-readable identifier for the root, which may be useful for display purposes or for referencing the root in other parts of the application.\n\nThe URI identifying the root. This *must* start with file:// for now.\nThis restriction may be relaxed in future versions of the protocol to allow\nother URI schemes.\n\n`SamplingMessage`\n\nDescribes a message issued to or received from an LLM API.\n\n`ServerCapabilities`\n\nCapabilities that a server may support. Known capabilities are defined here, in this schema, but this is not a closed set: any server can define its own, additional capabilities.\n\nPresent if the server supports argument autocompletion suggestions.\n\nExperimental, non-standard capabilities that the server supports.\n\nPresent if the server supports sending log messages to the client.\n\nPresent if the server offers any prompt templates.\n\n`Optional`\n\nlistChanged?: booleanWhether this server supports notifications for changes to the prompt list.\n\nPresent if the server offers any resources to read.\n\n`Optional`\n\nlistChanged?: booleanWhether this server supports notifications for changes to the resource list.\n\n`Optional`\n\nsubscribe?: booleanWhether this server supports subscribing to resource updates.\n\nPresent if the server offers any tools to call.\n\n`Optional`\n\nlistChanged?: booleanWhether this server supports notifications for changes to the tool list.\n\n`StringSchema`\n\n`TextContent`\n\nText provided to or from an LLM.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nOptional annotations for the client.\n\nThe text content of the message.\n\n`TextResourceContents`\n\nThe contents of a specific resource or sub-resource.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nThe MIME type of this resource, if known.\n\nThe text of the item. This must only be set if the item can actually be represented as text (not binary data).\n\nThe URI of this resource.\n\n`Tool`\n\nDefinition for a tool the client can call.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nOptional additional tool information.\n\nDisplay name precedence order is: title, annotations.title, then name.\n\nA human-readable description of the tool.\n\nThis can be used by clients to improve the LLM’s understanding of available tools. It can be thought of like a “hint” to the model.\n\nA JSON Schema object defining the expected parameters for the tool.\n\nIntended for programmatic or logical use, but used as a display name in past specs or fallback (if title isn’t present).\n\nAn optional JSON Schema object defining the structure of the tool’s output returned in the structuredContent field of a CallToolResult.\n\nIntended for UI and end-user contexts — optimized to be human-readable and easily understood, even by those unfamiliar with domain-specific terminology.\n\nIf not provided, the name should be used for display (except for Tool,\nwhere `annotations.title`\n\nshould be given precedence over using `name`\n\n,\nif present).\n\n`ToolAnnotations`\n\nAdditional properties describing a Tool to clients.\n\nNOTE: all properties in ToolAnnotations are **hints**.\nThey are not guaranteed to provide a faithful description of\ntool behavior (including descriptive properties like `title`\n\n).\n\nClients should never make tool use decisions based on ToolAnnotations received from untrusted servers.\n\nIf true, the tool may perform destructive updates to its environment. If false, the tool performs only additive updates.\n\n(This property is meaningful only when `readOnlyHint == false`\n\n)\n\nDefault: true\n\nIf true, calling the tool repeatedly with the same arguments will have no additional effect on the its environment.\n\n(This property is meaningful only when `readOnlyHint == false`\n\n)\n\nDefault: false\n\nIf true, this tool may interact with an “open world” of external entities. If false, the tool’s domain of interaction is closed. For example, the world of a web search tool is open, whereas that of a memory tool is not.\n\nDefault: true\n\nIf true, the tool does not modify its environment.\n\nDefault: false\n\nA human-readable title for the tool.\n\n`completion/complete`\n\n`CompleteRequest`\n\nA request from the client to the server, to ask for completion options.\n\nThe argument’s information\n\nThe name of the argument\n\nThe value of the argument to use for completion matching.\n\n`Optional`\n\ncontext?: { arguments?: { [key: string]: string } }Additional, optional context for completions\n\n`Optional`\n\narguments?: { [key: string]: string }Previously-resolved variables in a URI template or prompt.\n\n`CompleteResult`\n\nThe server’s response to a completion/complete request\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\n`Optional`\n\nhasMore?: booleanIndicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.\n\n`Optional`\n\ntotal?: numberThe total number of completion options available. This can exceed the number of values actually sent in the response.\n\nAn array of completion values. Must not exceed 100 items.\n\n`elicitation/create`\n\n`ElicitRequest`\n\nA request from the server to elicit additional information from the user via the client.\n\nThe message to present to the user.\n\nA restricted subset of JSON Schema. Only top-level properties are allowed, without nesting.\n\n`ElicitResult`\n\nThe client’s response to an elicitation request.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nThe user action in response to the elicitation.\n\nThe submitted form data, only present when action is “accept”. Contains values matching the requested schema.\n\n`initialize`\n\n`InitializeRequest`\n\nThis request is sent from the client to the server when it first connects, asking it to begin initialization.\n\nThe latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.\n\n`InitializeResult`\n\nAfter receiving an initialize request from the client, the server sends this response.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nInstructions describing how to use the server and its features.\n\nThis can be used by clients to improve the LLM’s understanding of available tools, resources, etc. It can be thought of like a “hint” to the model. For example, this information MAY be added to the system prompt.\n\nThe version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.\n\n`logging/setLevel`\n\n`SetLevelRequest`\n\nA request from the client to the server, to enable or adjust logging.\n\nThe level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/message.\n\n`notifications/cancelled`\n\n`CancelledNotification`\n\nThis notification can be sent by either side to indicate that it is cancelling a previously-issued request.\n\nThe request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.\n\nThis notification indicates that the result will be unused, so any associated processing SHOULD cease.\n\nA client MUST NOT attempt to cancel its `initialize`\n\nrequest.\n\n`Optional`\n\nreason?: stringAn optional string describing the reason for the cancellation. This MAY be logged or presented to the user.\n\nThe ID of the request to cancel.\n\nThis MUST correspond to the ID of a request previously issued in the same direction.\n\n`notifications/initialized`\n\n`InitializedNotification`\n\nThis notification is sent from the client to the server after initialization has finished.\n\n`Optional`\n\n_meta?: { [key: string]: unknown }See [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\n`notifications/message`\n\n`LoggingMessageNotification`\n\nNotification of a log message passed from server to client. If no logging/setLevel request has been sent from the client, the server MAY decide which messages to send automatically.\n\nThe data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.\n\nThe severity of this log message.\n\n`Optional`\n\nlogger?: stringAn optional name of the logger issuing this message.\n\n`notifications/progress`\n\n`ProgressNotification`\n\nAn out-of-band notification used to inform the receiver of a progress update for a long-running request.\n\n`Optional`\n\nmessage?: stringAn optional message describing the current progress.\n\nThe progress thus far. This should increase every time progress is made, even if the total is unknown.\n\nThe progress token which was given in the initial request, used to associate this notification with the request that is proceeding.\n\n`Optional`\n\ntotal?: numberTotal number of items to process (or total progress required), if known.\n\n`notifications/prompts/list_changed`\n\n`PromptListChangedNotification`\n\nAn optional notification from the server to the client, informing it that the list of prompts it offers has changed. This may be issued by servers without any previous subscription from the client.\n\n`Optional`\n\n_meta?: { [key: string]: unknown }See [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\n`notifications/resources/list_changed`\n\n`ResourceListChangedNotification`\n\nAn optional notification from the server to the client, informing it that the list of resources it can read from has changed. This may be issued by servers without any previous subscription from the client.\n\n`Optional`\n\n_meta?: { [key: string]: unknown }See [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\n`notifications/resources/updated`\n\n`ResourceUpdatedNotification`\n\nA notification from the server to the client, informing it that a resource has changed and may need to be read again. This should only be sent if the client previously sent a resources/subscribe request.\n\nThe URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.\n\n`notifications/roots/list_changed`\n\n`RootsListChangedNotification`\n\nA notification from the client to the server, informing it that the list of roots has changed. This notification should be sent whenever the client adds, removes, or modifies any root. The server should then request an updated list of roots using the ListRootsRequest.\n\n`Optional`\n\n_meta?: { [key: string]: unknown }See [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\n`notifications/tools/list_changed`\n\n`ToolListChangedNotification`\n\nAn optional notification from the server to the client, informing it that the list of tools it offers has changed. This may be issued by servers without any previous subscription from the client.\n\n`Optional`\n\n_meta?: { [key: string]: unknown }See [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\n`ping`\n\n`PingRequest`\n\nA ping, issued by either the server or the client, to check that the other party is still alive. The receiver must promptly respond, or else may be disconnected.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nIf specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\n\n`prompts/get`\n\n`GetPromptRequest`\n\nUsed by the client to get a prompt provided by the server.\n\n`Optional`\n\narguments?: { [key: string]: string }Arguments to use for templating the prompt.\n\nThe name of the prompt or prompt template.\n\n`GetPromptResult`\n\nThe server’s response to a prompts/get request from the client.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nAn optional description for the prompt.\n\n`prompts/list`\n\n`ListPromptsRequest`\n\nSent from the client to request a list of prompts and prompt templates the server has.\n\n`Optional`\n\ncursor?: stringAn opaque token representing the current pagination position. If provided, the server should return results starting after this cursor.\n\n`ListPromptsResult`\n\nThe server’s response to a prompts/list request from the client.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nAn opaque token representing the pagination position after the last returned result. If present, there may be more results available.\n\n`resources/list`\n\n`ListResourcesRequest`\n\nSent from the client to request a list of resources the server has.\n\n`Optional`\n\ncursor?: stringAn opaque token representing the current pagination position. If provided, the server should return results starting after this cursor.\n\n`ListResourcesResult`\n\nThe server’s response to a resources/list request from the client.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nAn opaque token representing the pagination position after the last returned result. If present, there may be more results available.\n\n`resources/read`\n\n`ReadResourceRequest`\n\nSent from the client to the server, to read a specific resource URI.\n\nThe URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.\n\n`ReadResourceResult`\n\nThe server’s response to a resources/read request from the client.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\n`resources/subscribe`\n\n`SubscribeRequest`\n\nSent from the client to request resources/updated notifications from the server whenever a particular resource changes.\n\nThe URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.\n\n`resources/templates/list`\n\n`ListResourceTemplatesRequest`\n\nSent from the client to request a list of resource templates the server has.\n\n`Optional`\n\ncursor?: stringAn opaque token representing the current pagination position. If provided, the server should return results starting after this cursor.\n\n`ListResourceTemplatesResult`\n\nThe server’s response to a resources/templates/list request from the client.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nAn opaque token representing the pagination position after the last returned result. If present, there may be more results available.\n\n`resources/unsubscribe`\n\n`UnsubscribeRequest`\n\nSent from the client to request cancellation of resources/updated notifications from the server. This should follow a previous resources/subscribe request.\n\nThe URI of the resource to unsubscribe from.\n\n`roots/list`\n\n`ListRootsRequest`\n\nSent from the server to request a list of root URIs from the client. Roots allow servers to ask for specific directories or files to operate on. A common example for roots is providing a set of repositories or directories a server should operate on.\n\nThis request is typically used when the server needs to understand the file system structure or access specific locations that the client has permission to read from.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nIf specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\n\n`ListRootsResult`\n\nThe client’s response to a roots/list request from the server. This result contains an array of Root objects, each representing a root directory or file that the server can operate on.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\n`sampling/createMessage`\n\n`CreateMessageRequest`\n\nA request from the server to sample an LLM via the client. The client has full discretion over which model to select. The client should also inform the user before beginning sampling, to allow them to inspect the request (human in the loop) and decide whether to approve it.\n\n`Optional`\n\nincludeContext?: “none” | “thisServer” | “allServers”A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.\n\nThe maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.\n\n`Optional`\n\nmetadata?: objectOptional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.\n\nThe server’s preferences for which model to select. The client MAY ignore these preferences.\n\n`Optional`\n\nstopSequences?: string[]`Optional`\n\nsystemPrompt?: stringAn optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.\n\n`Optional`\n\ntemperature?: number`CreateMessageResult`\n\nThe client’s response to a sampling/create_message request from the server. The client should inform the user before returning the sampled message, to allow them to inspect the response (human in the loop) and decide whether to allow the server to see it.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nThe name of the model that generated the message.\n\nThe reason why sampling stopped, if known.\n\n`tools/call`\n\n`CallToolRequest`\n\nUsed by the client to invoke a tool provided by the server.\n\n`CallToolResult`\n\nThe server’s response to a tool call.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nA list of content objects that represent the unstructured result of the tool call.\n\nWhether the tool call ended in an error.\n\nIf not set, this is assumed to be false (the call was successful).\n\nAny errors that originate from the tool SHOULD be reported inside the result\nobject, with `isError`\n\nset to true, *not* as an MCP protocol-level error\nresponse. Otherwise, the LLM would not be able to see that an error occurred\nand self-correct.\n\nHowever, any errors in *finding* the tool, an error indicating that the\nserver does not support tool calls, or any other exceptional conditions,\nshould be reported as an MCP error response.\n\nAn optional JSON object that represents the structured result of the tool call.\n\n`tools/list`\n\n`ListToolsRequest`\n\nSent from the client to request a list of tools the server has.\n\n`Optional`\n\ncursor?: stringAn opaque token representing the current pagination position. If provided, the server should return results starting after this cursor.\n\n`ListToolsResult`\n\nThe server’s response to a tools/list request from the client.\n\nSee [specification/2025-06-18/basic/index#general-fields] for notes on _meta usage.\n\nAn opaque token representing the pagination position after the last returned result. If present, there may be more results available.",
    "metadata": {
      "title": "Schema Reference - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/schema",
      "extracted_at": "2025-08-04T09:55:22.666001+00:00"
    },
    "word_count": 4566,
    "char_count": 32085,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:22.666210+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/development/roadmap",
    "content": "The Model Context Protocol is rapidly evolving. This page outlines our current thinking on key priorities and direction for approximately **the next six months**, though these may change significantly as the project develops. To see what’s changed recently, check out the **specification changelog**.\nThe ideas presented here are not commitments—we may solve these challenges differently than described, or some may not materialize at all. This is also not an *exhaustive* list; we may incorporate work that isn’t mentioned here.\n\nWe value community participation! Each section links to relevant discussions where you can learn more and contribute your thoughts.\nFor a technical view of our standardization process, visit the Standards Track on GitHub, which tracks how proposals progress toward inclusion in the official MCP specification.\n## Agents\n\nAs MCP increasingly becomes part of agentic workflows, we’re focusing on key improvements:\n**Asynchronous Operations**: supporting long-running operations that may take extended periods, with resilient handling of disconnections and reconnections\n\n## Authentication and Security\n\nWe’re evolving our authorization and security resources to improve user safety and provide a better developer experience:\n**Guides and Best Practices**: documenting specifics about deploying MCP securely in the form of guides and best practices to help developers avoid common pitfalls.\n**Alternatives to Dynamic Client Registration (DCR)**: exploring alternatives to DCR, attempting to address operational challenges while preserving a smooth user experience.\n**Fine-grained Authorization**: developing mechanisms and guidelines for primitive authorization for sensitive actions\n**Enterprise Managed Authorization**: adding the capability for enterprises to simplify MCP server authorization with the help of Single Sign-On (SSO)\n**Secure Authorization Elicitation**: enable developers to integrate secure authorization flows for downstream APIs outside the main MCP server authorization\n\n## Validation\n\nTo foster a robust developer ecosystem, we plan to invest in:\n**Reference Client Implementations**: demonstrating protocol features with high-quality AI applications\n**Reference Server Implementation**: showcasing authentication patterns and remote deployment best practices\n**Compliance Test Suites**: automated verification that clients, servers, and SDKs properly implement the specification\n\nThese tools will help developers confidently implement MCP while ensuring consistent behavior across the ecosystem.\n## Registry\n\nFor MCP to reach its full potential, we need streamlined ways to distribute and discover MCP servers.\nWe plan to develop an **MCP Registry** that will enable centralized server discovery and metadata. This registry will primarily function as an API layer that third-party marketplaces and discovery services can build upon.\n## Multimodality\n\nSupporting the full spectrum of AI capabilities in MCP, including:\n**Additional Modalities**: video and other media types\n**Streaming**: multipart, chunked messages, and bidirectional communication for interactive experiences\n\n## Get Involved\n\nWe welcome your contributions to MCP’s future! Join our GitHub Discussions to share ideas, provide feedback, or participate in the development process.",
    "metadata": {
      "title": "Roadmap - Model Context Protocol",
      "description": "Our plans for evolving Model Context Protocol",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/development/roadmap",
      "extracted_at": "2025-08-04T09:55:24.041914+00:00"
    },
    "word_count": 442,
    "char_count": 3299,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:24.041942+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/community/sep-guidelines",
    "content": "## What is a SEP?\n\nSEP stands for Specification Enhancement Proposal. A SEP is a design document providing information to the MCP community, or describing a new feature for the Model Context Protocol or its processes or environment. The SEP should provide a concise technical specification of the feature and a rationale for the feature.\nWe intend SEPs to be the primary mechanisms for proposing major new features, for collecting community input on an issue, and for documenting the design decisions that have gone into MCP. The SEP author is responsible for building consensus within the community and documenting dissenting opinions.\nBecause the SEPs are maintained as text files in a versioned repository (GitHub Issues), their revision history is the historical record of the feature proposal.\n## What qualifies a SEP?\n\nThe goal is to reserve the SEP process for changes that are substantial enough to require broad community discussion, a formal design document, and a historical record of the decision-making process. A regular GitHub issue or pull request is often more appropriate for smaller, more direct changes.\nConsider proposing a SEP if your change involves any of the following:\n**A New Feature or Protocol Change**: Any change that adds, modifies, or removes features in the Model Context Protocol. This includes:\n- Adding new API endpoints or methods.\n- Changing the syntax or semantics of existing data structures or messages.\n- Introducing a new standard for interoperability between different MCP-compatible tools.\n- Significant changes to how the specification itself is defined, presented, or validated.\n\n**A Breaking Change**: Any change that is not backwards-compatible.\n**A Change to Governance or Process**: Any proposal that alters the project’s decision-making, contribution guidelines (like this document itself).\n**A Complex or Controversial Topic**: If a change is likely to have multiple valid solutions or generate significant debate, the SEP process provides the necessary framework to explore alternatives, document the rationale, and build community consensus before implementation begins.\n\n## SEP Types\n\nThere are three kinds of SEP:\n**Standards Track** SEP describes a new feature or implementation for the Model Context Protocol. It may also describe an interoperability standard that will be supported outside the core protocol specification.\n**Informational** SEP describes a Model Context Protocol design issue, or provides general guidelines or information to the MCP community, but does not propose a new feature. Informational SEPs do not necessarily represent a MCP community consensus or recommendation.\n**Process** SEP describes a process surrounding MCP, or proposes a change to (or an event in) a process. Process SEPs are like Standards Track SEPs but apply to areas other than the MCP protocol itself.\n\n## Submitting a SEP\n\nThe SEP process begins with a new idea for the Model Context Protocol. It is highly recommended that a single SEP contain a single key proposal or new idea. Small enhancements or patches often don’t need a SEP and can be injected into the MCP development workflow with a pull request to the MCP repo. The more focused the SEP, the more successful it tends to be.\nEach SEP must have an **SEP author** — someone who writes the SEP using the style and format described below, shepherds the discussions in the appropriate forums, and attempts to build community consensus around the idea. The SEP author should first attempt to ascertain whether the idea is SEP-able. Posting to the MCP community forums (Discord, GitHub Discussions) is the best way to go about this.\n### SEP Workflow\n\nSEPs should be submitted as a GitHub Issue in the specification repository. The standard SEP workflow is:\n- You, the SEP author, create a well-formatted GitHub Issue with the\n`SEP`\n\nand `proposal`\n\ntags. The SEP number is the same as the GitHub Issue number, the two can be used interchangably.\n- Find a Core Maintainer or Maintainer to sponsor your proposal. Core Maintainers and Maintainers will regularly go over the list of open proposals to determine which proposals to sponsor. You can tag relevant maintainers from the maintainer list in your proposal.\n- Once a sponsor is found, the GitHub Issue is assigned to the sponsor. The sponsor will add the\n`draft`\n\ntag, ensure the SEP number is in the title, and assign a milestone.\n- The sponsor will informally review the proposal and may request changes based on community feedback. When ready for formal review, the sponsor will add the\n`in-review`\n\ntag.\n- After the\n`in-review`\n\ntag is added, the SEP enters formal review by the Core Maintainers team. The SEP may be accepted, rejected, or returned for revision.\n- If the SEP has not found a sponsor within three months, Core Maintainers may close the SEP as\n`dormant`\n\n.\n\nEach SEP should have the following parts:\n**Preamble** — A short descriptive title, the names and contact info for each author, the current status.\n**Abstract** — A short (~200 word) description of the technical issue being addressed.\n**Motivation** — The motivation should clearly explain why the existing protocol specification is inadequate to address the problem that the SEP solves. The motivation is critical for SEPs that want to change the Model Context Protocol. SEP submissions without sufficient motivation may be rejected outright.\n**Specification** — The technical specification should describe the syntax and semantics of any new protocol feature. The specification should be detailed enough to allow competing, interoperable implementations. A PR with the changes to the specification should be provided.\n**Rationale** — The rationale explains why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion.\n**Backward Compatibility** — All SEPs that introduce backward incompatibilities must include a section describing these incompatibilities and their severity. The SEP must explain how the author proposes to deal with these incompatibilities.\n**Reference Implementation** — The reference implementation must be completed before any SEP is given status “Final”, but it need not be completed before the SEP is accepted. While there is merit to the approach of reaching consensus on the specification and rationale before writing code, the principle of “rough consensus and running code” is still useful when it comes to resolving many discussions of protocol details.\n**Security Implications** — If there are security concerns in relation to the SEP, those concerns should be explicitly written out to make sure reviewers of the SEP are aware of them.\n\n### SEP States\n\nSEPs can be one one of the following states\n`proposal`\n\n: SEP proposal without a sponsor.\n`draft`\n\n: SEP proposal with a sponsor.\n`in-review`\n\n: SEP proposal ready for review.\n`accepted`\n\n: SEP accepted by Core Maintainers, but still requires final wording and reference implementation.\n`rejected`\n\n: SEP rejected by Core Maintainers.\n`withdrawn`\n\n: SEP withdrawn.\n`final`\n\n: SEP finalized.\n`superseded`\n\n: SEP has been replaced by a newer SEP.\n`dormant`\n\n: SEP that has not found sponsors and was subsequently closed.\n\n### SEP Review & Resolution\n\nSEPs are reviewed by the MCP Core Maintainers team on a bi-weekly basis.\nFor a SEP to be accepted it must meet certain minimum criteria:\n- A prototype implementation demonstrating the proposal\n- Clear benefit to the MCP ecosystem\n- Community support and consensus\n\nOnce a SEP has been accepted, the reference implementation must be completed. When the reference implementation is complete and incorporated into the main source code repository, the status will be changed to “Final”.\nA SEP can also be “Rejected” or “Withdrawn”. A SEP that is “Withdrawn” may be re-submitted at a later date.\n## Reporting SEP Bugs, or Submitting SEP Updates\n\nHow you report a bug, or submit a SEP update depends on several factors, such as the maturity of the SEP, the preferences of the SEP author, and the nature of your comments. For SEPs not yet reaching `final`\n\nstate, it’s probably best to send your comments and changes directly to the SEP author. Once SEP is finalized, you may want to submit corrections as a GitHub comment on the issue or pull request to the reference implementation.\n## Transferring SEP Ownership\n\nIt occasionally becomes necessary to transfer ownership of SEPs to a new SEP author. In general, we’d like to retain the original author as a co-author of the transferred SEP, but that’s really up to the original author. A good reason to transfer ownership is because the original author no longer has the time or interest in updating it or following through with the SEP process, or has fallen off the face of the ‘net (i.e. is unreachable or not responding to email). A bad reason to transfer ownership is because you don’t agree with the direction of the SEP. We try to build consensus around a SEP, but if that’s not possible, you can always submit a competing SEP.\n## Copyright\n\nThis document is placed in the public domain or under the CC0-1.0-Universal license, whichever is more permissive.",
    "metadata": {
      "title": "SEP Guidelines - Model Context Protocol",
      "description": "Specification Enhancement Proposal (SEP) guidelines for proposing changes to the Model Context Protocol",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/community/sep-guidelines",
      "extracted_at": "2025-08-04T09:55:25.501577+00:00"
    },
    "word_count": 1480,
    "char_count": 9280,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:25.501650+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/community/communication",
    "content": "This document provides practical guidance for communicating and collaborating within the Model Context Protocol (MCP) project. It outlines the communication channels, workflows, and processes used by the MCP community.\nAll communication within the MCP community is governed by our Code of Conduct. We expect all participants to maintain respectful, professional, and inclusive interactions across all channels.\n## Communication Channels\n\nWe support three primary communication channels: the public Discord server, GitHub Issues, and GitHub Discussions in the main project repository.\n### Discord\n\nFor real-time contributor discussion and collaboration. The server is designed around **MCP contributors** and is not intended\nto be a place for general MCP support.\nThe Discord server will have both public and private channels.\n#### Public Channels (Default)\n\n**Purpose**: Open community engagement, collaborative development, and transparent project coordination.\n- Primary use cases:\n**Public SDK and tooling development**: All development, from ideation to release planning, happens in public channels (e.g., `#typescript-sdk-dev`\n\n, `#inspector-dev`\n\n).\n**Working and interest group discussions** (`#client-implementors`\n\n, `#agents-wg`\n\n, etc.)\n**Working Group**: Some specific goal or project in mind (such as an SDK, inspector, registry, server-identity, load-balancing, etc).\n**Interest Group**: An abstract gathering of folks that might raise a range of various topics. Some might get actioned on as one-offs, others might spin into Working Groups.\n\n**Community onboarding** and contribution guidance.\n**Community feedback** and collaborative brainstorming.\n- Public\n**office hours** and **maintainer availability**.\n\n- Avoid:\n- MCP user support: participants are expected to read official documentation and start new GitHub Discussions for questions or support.\n- Service or product marketing: interactions on this Discord are expected to be vendor-neutral and not used for brand-building or sales. Mentions of brands or products are discouraged outside of being used as examples or responses to conversations that start off focused on the specification.\n\n\n#### Private channels (Exceptions)\n\n**Purpose**: Confidential coordination and sensitive matters that cannot be discussed publicly. Access will be restricted to designated maintainers.\n**Strict criteria for private use**:\n**Security incidents** (CVEs, protocol vulnerabilities).\n**People matters** (maintainer-related discussions, code of conduct policies).\n- Select channels will be configured to be\n**read-only**. This can be good for example for maintainer decision making.\n- Coordination requiring\n**immediate** or otherwise **focused response** with a limited audience.\n\n**Transparency**:\n**All technical and governance decisions** affecting the community **must be documented** in GitHub Discussions and/or Issues, and will be labeled with `notes`\n\n.\n**Some matters related to individual contributors** may remain private when appropriate (e.g., personal circumstances, disciplinary actions, or other sensitive individual matters).\n- Private channels are to be used as\n**temporary “incident rooms,”** not for routine development.\n\n\nAny significant discussion on Discord that leads to a potential decision or proposal must be moved to a GitHub Discussion or GitHub Issue to create a persistent, searchable record. Proposals will then be promoted to full-fledged PRs with associated work items (GitHub Issues) as needed.\n### GitHub Discussions\n\nFor structured, long-form discussion and debate on project direction, features, improvements, and community topics.\nWhen to use:\n- Project roadmap planning and milestone discussions\n- Announcements and release communications\n- Community polls and consensus-building processes\n- Feature requests with context and rationale\n- If a particular repository does not have GitHub Discussions enabled, feel free to open a GitHub Issue instead.\n\n\n### GitHub Issues\n\nFor bug reports, feature tracking, and actionable development tasks.\nWhen to use:\n- Submit SEP proposals (following the SEP guidelines)\n- Bug reports with reproducible steps\n- Documentation improvements with specific scope\n- CI/CD problems and infrastructure issues\n- Release tasks and milestone tracking\n\n### Security Issues\n\n**Do not post security issues publicly.** Instead:\n- Use the private security reporting process. For protocol-level security issues, follow the process in SECURITY.md in the modelcontextprotocol GitHub repository.\n- Contact lead and/or core maintainers directly.\n- Follow responsible disclosure guidelines.\n\n## Decision Records\n\nAll MCP decisions are documented and captured in public channels.\nWhen documenting decisions, we will retain as much context as possible:\n- Decision makers\n- Background context and motivation\n- Options that were considered\n- Rationale for the chosen approach\n- Implementation steps",
    "metadata": {
      "title": "Contributor Communication - Model Context Protocol",
      "description": "Communication strategy and framework for the Model Context Protocol community",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/community/communication",
      "extracted_at": "2025-08-04T09:55:26.956124+00:00"
    },
    "word_count": 671,
    "char_count": 4907,
    "crawl_depth": 2,
    "crawled_at": "2025-08-04T09:55:26.956177+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/concepts/tools",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) allows servers to expose tools that can be invoked by\nlanguage models. Tools enable models to interact with external systems, such as querying\ndatabases, calling APIs, or performing computations. Each tool is uniquely identified by\na name and includes metadata describing its schema.\n## User Interaction Model\n\nTools in MCP are designed to be **model-controlled**, meaning that the language model can\ndiscover and invoke tools automatically based on its contextual understanding and the\nuser’s prompts.\nHowever, implementations are free to expose tools through any interface pattern that\nsuits their needs—the protocol itself does not mandate any specific user\ninteraction model.\nFor trust & safety and security, there **SHOULD** always\nbe a human in the loop with the ability to deny tool invocations.Applications **SHOULD**:\n- Provide UI that makes clear which tools are being exposed to the AI model\n- Insert clear visual indicators when tools are invoked\n- Present confirmation prompts to the user for operations, to ensure a human is in the\nloop\n\n## Capabilities\n\nServers that support tools **MUST** declare the `tools`\n\ncapability:\n`listChanged`\n\nindicates whether the server will emit notifications when the list of\navailable tools changes.\n## Protocol Messages\n\nTo discover available tools, clients send a `tools/list`\n\nrequest. This operation supports\npagination.\n**Request:**\n**Response:**\nTo invoke a tool, clients send a `tools/call`\n\nrequest:\n**Request:**\n**Response:**\n### List Changed Notification\n\nWhen the list of available tools changes, servers that declared the `listChanged`\n\ncapability **SHOULD** send a notification:\n## Message Flow\n\n## Data Types\n\nA tool definition includes:\n`name`\n\n: Unique identifier for the tool\n`title`\n\n: Optional human-readable name of the tool for display purposes.\n`description`\n\n: Human-readable description of functionality\n`inputSchema`\n\n: JSON Schema defining expected parameters\n`outputSchema`\n\n: Optional JSON Schema defining expected output structure\n`annotations`\n\n: optional properties describing tool behavior\n\nFor trust & safety and security, clients **MUST** consider\ntool annotations to be untrusted unless they come from trusted servers.\n\nTool results may contain **structured** or **unstructured** content.\n**Unstructured** content is returned in the `content`\n\nfield of a result, and can contain multiple content items of different types:\nAll content types (text, image, audio, resource links, and embedded resources)\nsupport optional\nannotations that\nprovide metadata about audience, priority, and modification times. This is the\nsame annotation format used by resources and prompts.\n#### Text Content\n\n#### Image Content\n\nThis example demonstrates the use of an optional Annotation.\n#### Audio Content\n\n#### Resource Links\n\nA tool **MAY** return links to Resources, to provide additional context\nor data. In this case, the tool will return a URI that can be subscribed to or fetched by the client:\nResource links support the same Resource annotations as regular resources to help clients understand how to use them.\nResource links returned by tools are not guaranteed to appear in the results\nof a `resources/list`\n\nrequest.\n\n#### Embedded Resources\n\nResources **MAY** be embedded to provide additional context\nor data using a suitable URI scheme. Servers that use embedded resources **SHOULD** implement the `resources`\n\ncapability:\nEmbedded resources support the same Resource annotations as regular resources to help clients understand how to use them.\n#### Structured Content\n\n**Structured** content is returned as a JSON object in the `structuredContent`\n\nfield of a result.\nFor backwards compatibility, a tool that returns structured content SHOULD also return the serialized JSON in a TextContent block.\n#### Output Schema\n\nTools may also provide an output schema for validation of structured results.\nIf an output schema is provided:\n- Servers\n**MUST** provide structured results that conform to this schema.\n- Clients\n**SHOULD** validate structured results against this schema.\n\nExample tool with output schema:\nExample valid response for this tool:\nProviding an output schema helps clients and LLMs understand and properly handle structured tool outputs by:\n- Enabling strict schema validation of responses\n- Providing type information for better integration with programming languages\n- Guiding clients and LLMs to properly parse and utilize the returned data\n- Supporting better documentation and developer experience\n\n## Error Handling\n\nTools use two error reporting mechanisms:\n-\n**Protocol Errors**: Standard JSON-RPC errors for issues like:\n- Unknown tools\n- Invalid arguments\n- Server errors\n\n-\n**Tool Execution Errors**: Reported in tool results with `isError: true`\n\n:\n- API failures\n- Invalid input data\n- Business logic errors\n\n\nExample protocol error:\nExample tool execution error:\n## Security Considerations\n\n-\nServers\n**MUST**:\n- Validate all tool inputs\n- Implement proper access controls\n- Rate limit tool invocations\n- Sanitize tool outputs\n\n-\nClients\n**SHOULD**:\n- Prompt for user confirmation on sensitive operations\n- Show tool inputs to the user before calling the server, to avoid malicious or\naccidental data exfiltration\n- Validate tool results before passing to LLM\n- Implement timeouts for tool calls\n- Log tool usage for audit purposes",
    "metadata": {
      "title": "Tools - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/concepts/tools",
      "extracted_at": "2025-08-04T09:55:29.782949+00:00"
    },
    "word_count": 795,
    "char_count": 5408,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:29.783005+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/concepts/prompts",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for servers to expose prompt\ntemplates to clients. Prompts allow servers to provide structured messages and\ninstructions for interacting with language models. Clients can discover available\nprompts, retrieve their contents, and provide arguments to customize them.\n## User Interaction Model\n\nPrompts are designed to be **user-controlled**, meaning they are exposed from servers to\nclients with the intention of the user being able to explicitly select them for use.\nTypically, prompts would be triggered through user-initiated commands in the user\ninterface, which allows users to naturally discover and invoke available prompts.\nFor example, as slash commands:\nHowever, implementors are free to expose prompts through any interface pattern that suits\ntheir needs—the protocol itself does not mandate any specific user interaction\nmodel.\n## Capabilities\n\nServers that support prompts **MUST** declare the `prompts`\n\ncapability during\ninitialization:\n`listChanged`\n\nindicates whether the server will emit notifications when the list of\navailable prompts changes.\n## Protocol Messages\n\n### Listing Prompts\n\nTo retrieve available prompts, clients send a `prompts/list`\n\nrequest. This operation\nsupports pagination.\n**Request:**\n**Response:**\n### Getting a Prompt\n\nTo retrieve a specific prompt, clients send a `prompts/get`\n\nrequest. Arguments may be\nauto-completed through the completion API.\n**Request:**\n**Response:**\n### List Changed Notification\n\nWhen the list of available prompts changes, servers that declared the `listChanged`\n\ncapability **SHOULD** send a notification:\n## Message Flow\n\n## Data Types\n\n### Prompt\n\nA prompt definition includes:\n`name`\n\n: Unique identifier for the prompt\n`title`\n\n: Optional human-readable name of the prompt for display purposes.\n`description`\n\n: Optional human-readable description\n`arguments`\n\n: Optional list of arguments for customization\n\n### PromptMessage\n\nMessages in a prompt can contain:\n`role`\n\n: Either “user” or “assistant” to indicate the speaker\n`content`\n\n: One of the following content types:\n\nAll content types in prompt messages support optional\nannotations for\nmetadata about audience, priority, and modification times.\n#### Text Content\n\nText content represents plain text messages:\nThis is the most common content type used for natural language interactions.\n#### Image Content\n\nImage content allows including visual information in messages:\nThe image data **MUST** be base64-encoded and include a valid MIME type. This enables\nmulti-modal interactions where visual context is important.\n#### Audio Content\n\nAudio content allows including audio information in messages:\nThe audio data MUST be base64-encoded and include a valid MIME type. This enables\nmulti-modal interactions where audio context is important.\n#### Embedded Resources\n\nEmbedded resources allow referencing server-side resources directly in messages:\nResources can contain either text or binary (blob) data and **MUST** include:\n- A valid resource URI\n- The appropriate MIME type\n- Either text content or base64-encoded blob data\n\nEmbedded resources enable prompts to seamlessly incorporate server-managed content like\ndocumentation, code samples, or other reference materials directly into the conversation\nflow.\n## Error Handling\n\nServers **SHOULD** return standard JSON-RPC errors for common failure cases:\n- Invalid prompt name:\n`-32602`\n\n(Invalid params)\n- Missing required arguments:\n`-32602`\n\n(Invalid params)\n- Internal errors:\n`-32603`\n\n(Internal error)\n\n## Implementation Considerations\n\n- Servers\n**SHOULD** validate prompt arguments before processing\n- Clients\n**SHOULD** handle pagination for large prompt lists\n- Both parties\n**SHOULD** respect capability negotiation\n\n## Security\n\nImplementations **MUST** carefully validate all prompt inputs and outputs to prevent\ninjection attacks or unauthorized access to resources.",
    "metadata": {
      "title": "Prompts - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/concepts/prompts",
      "extracted_at": "2025-08-04T09:55:31.672767+00:00"
    },
    "word_count": 541,
    "char_count": 3958,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:31.672809+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/concepts/sampling",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for servers to request LLM\nsampling (“completions” or “generations”) from language models via clients. This flow\nallows clients to maintain control over model access, selection, and permissions while\nenabling servers to leverage AI capabilities—with no server API keys necessary.\nServers can request text, audio, or image-based interactions and optionally include\ncontext from MCP servers in their prompts.\n## User Interaction Model\n\nSampling in MCP allows servers to implement agentic behaviors, by enabling LLM calls to\noccur *nested* inside other MCP server features.\nImplementations are free to expose sampling through any interface pattern that suits\ntheir needs—the protocol itself does not mandate any specific user interaction\nmodel.\nFor trust & safety and security, there **SHOULD** always\nbe a human in the loop with the ability to deny sampling requests.Applications **SHOULD**:\n- Provide UI that makes it easy and intuitive to review sampling requests\n- Allow users to view and edit prompts before sending\n- Present generated responses for review before delivery\n\n## Capabilities\n\nClients that support sampling **MUST** declare the `sampling`\n\ncapability during\ninitialization:\n## Protocol Messages\n\n### Creating Messages\n\nTo request a language model generation, servers send a `sampling/createMessage`\n\nrequest:\n**Request:**\n**Response:**\n## Message Flow\n\n## Data Types\n\n### Messages\n\nSampling messages can contain:\n#### Text Content\n\n#### Image Content\n\n#### Audio Content\n\n### Model Preferences\n\nModel selection in MCP requires careful abstraction since servers and clients may use\ndifferent AI providers with distinct model offerings. A server cannot simply request a\nspecific model by name since the client may not have access to that exact model or may\nprefer to use a different provider’s equivalent model.\nTo solve this, MCP implements a preference system that combines abstract capability\npriorities with optional model hints:\n#### Capability Priorities\n\nServers express their needs through three normalized priority values (0-1):\n`costPriority`\n\n: How important is minimizing costs? Higher values prefer cheaper models.\n`speedPriority`\n\n: How important is low latency? Higher values prefer faster models.\n`intelligencePriority`\n\n: How important are advanced capabilities? Higher values prefer\nmore capable models.\n\n#### Model Hints\n\nWhile priorities help select models based on characteristics, `hints`\n\nallow servers to\nsuggest specific models or model families:\n- Hints are treated as substrings that can match model names flexibly\n- Multiple hints are evaluated in order of preference\n- Clients\n**MAY** map hints to equivalent models from different providers\n- Hints are advisory—clients make final model selection\n\nFor example:\nThe client processes these preferences to select an appropriate model from its available\noptions. For instance, if the client doesn’t have access to Claude models but has Gemini,\nit might map the sonnet hint to `gemini-1.5-pro`\n\nbased on similar capabilities.\n## Error Handling\n\nClients **SHOULD** return errors for common failure cases:\nExample error:\n## Security Considerations\n\n- Clients\n**SHOULD** implement user approval controls\n- Both parties\n**SHOULD** validate message content\n- Clients\n**SHOULD** respect model preference hints\n- Clients\n**SHOULD** implement rate limiting\n- Both parties\n**MUST** handle sensitive data appropriately",
    "metadata": {
      "title": "Sampling - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/concepts/sampling",
      "extracted_at": "2025-08-04T09:55:33.425912+00:00"
    },
    "word_count": 500,
    "char_count": 3492,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:33.425947+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/concepts/roots",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for clients to expose\nfilesystem “roots” to servers. Roots define the boundaries of where servers can operate\nwithin the filesystem, allowing them to understand which directories and files they have\naccess to. Servers can request the list of roots from supporting clients and receive\nnotifications when that list changes.\n## User Interaction Model\n\nRoots in MCP are typically exposed through workspace or project configuration interfaces.\nFor example, implementations could offer a workspace/project picker that allows users to\nselect directories and files the server should have access to. This can be combined with\nautomatic workspace detection from version control systems or project files.\nHowever, implementations are free to expose roots through any interface pattern that\nsuits their needs—the protocol itself does not mandate any specific user\ninteraction model.\n## Capabilities\n\nClients that support roots **MUST** declare the `roots`\n\ncapability during\ninitialization:\n`listChanged`\n\nindicates whether the client will emit notifications when the list of roots\nchanges.\n## Protocol Messages\n\n### Listing Roots\n\nTo retrieve roots, servers send a `roots/list`\n\nrequest:\n**Request:**\n**Response:**\n### Root List Changes\n\nWhen roots change, clients that support `listChanged`\n\n**MUST** send a notification:\n## Message Flow\n\n## Data Types\n\n### Root\n\nA root definition includes:\n`uri`\n\n: Unique identifier for the root. This **MUST** be a `file://`\n\nURI in the current\nspecification.\n`name`\n\n: Optional human-readable name for display purposes.\n\nExample roots for different use cases:\n#### Project Directory\n\n#### Multiple Repositories\n\n## Error Handling\n\nClients **SHOULD** return standard JSON-RPC errors for common failure cases:\n- Client does not support roots:\n`-32601`\n\n(Method not found)\n- Internal errors:\n`-32603`\n\n\nExample error:\n## Security Considerations\n\n-\nClients\n**MUST**:\n- Only expose roots with appropriate permissions\n- Validate all root URIs to prevent path traversal\n- Implement proper access controls\n- Monitor root accessibility\n\n-\nServers\n**SHOULD**:\n- Handle cases where roots become unavailable\n- Respect root boundaries during operations\n- Validate all paths against provided roots\n\n\n## Implementation Guidelines\n\n-\nClients\n**SHOULD**:\n- Prompt users for consent before exposing roots to servers\n- Provide clear user interfaces for root management\n- Validate root accessibility before exposing\n- Monitor for root changes\n\n-\nServers\n**SHOULD**:\n- Check for roots capability before usage\n- Handle root list changes gracefully\n- Respect root boundaries in operations\n- Cache root information appropriately",
    "metadata": {
      "title": "Roots - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/concepts/roots",
      "extracted_at": "2025-08-04T09:55:35.800855+00:00"
    },
    "word_count": 391,
    "char_count": 2728,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:35.800886+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/concepts/resources",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for servers to expose\nresources to clients. Resources allow servers to share data that provides context to\nlanguage models, such as files, database schemas, or application-specific information.\nEach resource is uniquely identified by a\nURI.\n## User Interaction Model\n\nResources in MCP are designed to be **application-driven**, with host applications\ndetermining how to incorporate context based on their needs.\nFor example, applications could:\n- Expose resources through UI elements for explicit selection, in a tree or list view\n- Allow the user to search through and filter available resources\n- Implement automatic context inclusion, based on heuristics or the AI model’s selection\n\nHowever, implementations are free to expose resources through any interface pattern that\nsuits their needs—the protocol itself does not mandate any specific user\ninteraction model.\n## Capabilities\n\nServers that support resources **MUST** declare the `resources`\n\ncapability:\nThe capability supports two optional features:\n`subscribe`\n\n: whether the client can subscribe to be notified of changes to individual\nresources.\n`listChanged`\n\n: whether the server will emit notifications when the list of available\nresources changes.\n\nBoth `subscribe`\n\nand `listChanged`\n\nare optional—servers can support neither,\neither, or both:\n## Protocol Messages\n\n### Listing Resources\n\nTo discover available resources, clients send a `resources/list`\n\nrequest. This operation\nsupports pagination.\n**Request:**\n**Response:**\n### Reading Resources\n\nTo retrieve resource contents, clients send a `resources/read`\n\nrequest:\n**Request:**\n**Response:**\n### Resource Templates\n\nResource templates allow servers to expose parameterized resources using\nURI templates. Arguments may be\nauto-completed through the completion API.\n**Request:**\n**Response:**\n### List Changed Notification\n\nWhen the list of available resources changes, servers that declared the `listChanged`\n\ncapability **SHOULD** send a notification:\n### Subscriptions\n\nThe protocol supports optional subscriptions to resource changes. Clients can subscribe\nto specific resources and receive notifications when they change:\n**Subscribe Request:**\n**Update Notification:**\n## Message Flow\n\n## Data Types\n\n### Resource\n\nA resource definition includes:\n`uri`\n\n: Unique identifier for the resource\n`name`\n\n: The name of the resource.\n`title`\n\n: Optional human-readable name of the resource for display purposes.\n`description`\n\n: Optional description\n`mimeType`\n\n: Optional MIME type\n`size`\n\n: Optional size in bytes\n\n### Resource Contents\n\nResources can contain either text or binary data:\n#### Text Content\n\n#### Binary Content\n\n### Annotations\n\nResources, resource templates and content blocks support optional annotations that provide hints to clients about how to use or display the resource:\n`audience`\n\n: An array indicating the intended audience(s) for this resource. Valid values are `\"user\"`\n\nand `\"assistant\"`\n\n. For example, `[\"user\", \"assistant\"]`\n\nindicates content useful for both.\n`priority`\n\n: A number from 0.0 to 1.0 indicating the importance of this resource. A value of 1 means “most important” (effectively required), while 0 means “least important” (entirely optional).\n`lastModified`\n\n: An ISO 8601 formatted timestamp indicating when the resource was last modified (e.g., `\"2025-01-12T15:00:58Z\"`\n\n).\n\nExample resource with annotations:\nClients can use these annotations to:\n- Filter resources based on their intended audience\n- Prioritize which resources to include in context\n- Display modification times or sort by recency\n\n## Common URI Schemes\n\nThe protocol defines several standard URI schemes. This list not\nexhaustive—implementations are always free to use additional, custom URI schemes.\n### https://\n\nUsed to represent a resource available on the web.\nServers **SHOULD** use this scheme only when the client is able to fetch and load the\nresource directly from the web on its own—that is, it doesn’t need to read the resource\nvia the MCP server.\nFor other use cases, servers **SHOULD** prefer to use another URI scheme, or define a\ncustom one, even if the server will itself be downloading resource contents over the\ninternet.\n### file://\n\nUsed to identify resources that behave like a filesystem. However, the resources do not\nneed to map to an actual physical filesystem.\nMCP servers **MAY** identify file:// resources with an\nXDG MIME type,\nlike `inode/directory`\n\n, to represent non-regular files (such as directories) that don’t\notherwise have a standard MIME type.\n### git://\n\nGit version control integration.\n### Custom URI Schemes\n\nCustom URI schemes **MUST** be in accordance with RFC3986,\ntaking the above guidance in to account.\n## Error Handling\n\nServers **SHOULD** return standard JSON-RPC errors for common failure cases:\n- Resource not found:\n`-32002`\n\n- Internal errors:\n`-32603`\n\n\nExample error:\n## Security Considerations\n\n- Servers\n**MUST** validate all resource URIs\n- Access controls\n**SHOULD** be implemented for sensitive resources\n- Binary data\n**MUST** be properly encoded\n- Resource permissions\n**SHOULD** be checked before operations",
    "metadata": {
      "title": "Resources - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/concepts/resources",
      "extracted_at": "2025-08-04T09:55:37.557543+00:00"
    },
    "word_count": 743,
    "char_count": 5212,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:37.557590+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/docs/concepts/elicitation",
    "content": "**Protocol Revision**: 2025-06-18\n\nElicitation is newly introduced in this version of the MCP specification and its design may evolve in future protocol versions.\n\nThe Model Context Protocol (MCP) provides a standardized way for servers to request additional\ninformation from users through the client during interactions. This flow allows clients to\nmaintain control over user interactions and data sharing while enabling servers to gather\nnecessary information dynamically.\nServers request structured data from users with JSON schemas to validate responses.\n## User Interaction Model\n\nElicitation in MCP allows servers to implement interactive workflows by enabling user input\nrequests to occur *nested* inside other MCP server features.\nImplementations are free to expose elicitation through any interface pattern that suits\ntheir needs—the protocol itself does not mandate any specific user interaction\nmodel.\nFor trust & safety and security:\n- Servers\n**MUST NOT** use elicitation to request sensitive information.\n\nApplications **SHOULD**:\n- Provide UI that makes it clear which server is requesting information\n- Allow users to review and modify their responses before sending\n- Respect user privacy and provide clear decline and cancel options\n\n## Capabilities\n\nClients that support elicitation **MUST** declare the `elicitation`\n\ncapability during\ninitialization:\n## Protocol Messages\n\n### Creating Elicitation Requests\n\nTo request information from a user, servers send an `elicitation/create`\n\nrequest:\n#### Simple Text Request\n\n**Request:**\n**Response:**\n#### Structured Data Request\n\n**Request:**\n**Response:**\n**Reject Response Example:**\n**Cancel Response Example:**\n## Message Flow\n\n## Request Schema\n\nThe `requestedSchema`\n\nfield allows servers to define the structure of the expected response using a restricted subset of JSON Schema. To simplify implementation for clients, elicitation schemas are limited to flat objects with primitive properties only:\n### Supported Schema Types\n\nThe schema is restricted to these primitive types:\n-\n**String Schema**\nSupported formats: `email`\n\n, `uri`\n\n, `date`\n\n, `date-time`\n\n-\n**Number Schema**\n-\n**Boolean Schema**\n-\n**Enum Schema**\n\nClients can use this schema to:\n- Generate appropriate input forms\n- Validate user input before sending\n- Provide better guidance to users\n\nNote that complex nested structures, arrays of objects, and other advanced JSON Schema features are intentionally not supported to simplify client implementation.\n## Response Actions\n\nElicitation responses use a three-action model to clearly distinguish between different user actions:\nThe three response actions are:\n-\n**Accept** (`action: \"accept\"`\n\n): User explicitly approved and submitted with data\n- The\n`content`\n\nfield contains the submitted data matching the requested schema\n- Example: User clicked “Submit”, “OK”, “Confirm”, etc.\n\n-\n**Decline** (`action: \"decline\"`\n\n): User explicitly declined the request\n- The\n`content`\n\nfield is typically omitted\n- Example: User clicked “Reject”, “Decline”, “No”, etc.\n\n-\n**Cancel** (`action: \"cancel\"`\n\n): User dismissed without making an explicit choice\n- The\n`content`\n\nfield is typically omitted\n- Example: User closed the dialog, clicked outside, pressed Escape, etc.\n\n\nServers should handle each state appropriately:\n**Accept**: Process the submitted data\n**Decline**: Handle explicit decline (e.g., offer alternatives)\n**Cancel**: Handle dismissal (e.g., prompt again later)\n\n## Security Considerations\n\n- Servers\n**MUST NOT** request sensitive information through elicitation\n- Clients\n**SHOULD** implement user approval controls\n- Both parties\n**SHOULD** validate elicitation content against the provided schema\n- Clients\n**SHOULD** provide clear indication of which server is requesting information\n- Clients\n**SHOULD** allow users to decline elicitation requests at any time\n- Clients\n**SHOULD** implement rate limiting\n- Clients\n**SHOULD** present elicitation requests in a way that makes it clear what information is being requested and why",
    "metadata": {
      "title": "Elicitation - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/docs/concepts/elicitation",
      "extracted_at": "2025-08-04T09:55:39.388578+00:00"
    },
    "word_count": 562,
    "char_count": 4034,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:39.388616+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/legacy/concepts/transports",
    "content": "Transports in the Model Context Protocol (MCP) provide the foundation for communication between clients and servers. A transport handles the underlying mechanics of how messages are sent and received.\nMCP uses JSON-RPC 2.0 as its wire format. The transport layer is responsible for converting MCP protocol messages into JSON-RPC format for transmission and converting received JSON-RPC messages back into MCP protocol messages.\nThere are three types of JSON-RPC messages used:\n### Requests\n\n### Responses\n\n### Notifications\n\n## Built-in Transport Types\n\nMCP currently defines two standard transport mechanisms:\nThe stdio transport enables communication through standard input and output streams. This is particularly useful for local integrations and command-line tools.\nUse stdio when:\n- Building command-line tools\n- Implementing local integrations\n- Needing simple process communication\n- Working with shell scripts\n\n#### Server\n\n#### Client\n\n### Streamable HTTP\n\nThe Streamable HTTP transport uses HTTP POST requests for client-to-server communication and optional Server-Sent Events (SSE) streams for server-to-client communication.\nUse Streamable HTTP when:\n- Building web-based integrations\n- Needing client-server communication over HTTP\n- Requiring stateful sessions\n- Supporting multiple concurrent clients\n- Implementing resumable connections\n\n#### How it Works\n\n**Client-to-Server Communication**: Every JSON-RPC message from client to server is sent as a new HTTP POST request to the MCP endpoint\n**Server Responses**: The server can respond either with:\n- A single JSON response (\n`Content-Type: application/json`\n\n)\n- An SSE stream (\n`Content-Type: text/event-stream`\n\n) for multiple messages\n\n**Server-to-Client Communication**: Servers can send requests/notifications to clients via:\n- SSE streams initiated by client requests\n- SSE streams from HTTP GET requests to the MCP endpoint\n\n\n#### Server\n\n#### Client\n\n#### Session Management\n\nStreamable HTTP supports stateful sessions to maintain context across multiple requests:\n**Session Initialization**: Servers may assign a session ID during initialization by including it in an `Mcp-Session-Id`\n\nheader\n**Session Persistence**: Clients must include the session ID in all subsequent requests using the `Mcp-Session-Id`\n\nheader\n**Session Termination**: Sessions can be explicitly terminated by sending an HTTP DELETE request with the session ID\n\nExample session flow:\n#### Resumability and Redelivery\n\nTo support resuming broken connections, Streamable HTTP provides:\n**Event IDs**: Servers can attach unique IDs to SSE events for tracking\n**Resume from Last Event**: Clients can resume by sending the `Last-Event-ID`\n\nheader\n**Message Replay**: Servers can replay missed messages from the disconnection point\n\nThis ensures reliable message delivery even with unstable network connections.\n#### Security Considerations\n\nWhen implementing Streamable HTTP transport, follow these security best practices:\n**Validate Origin Headers**: Always validate the `Origin`\n\nheader on all incoming connections to prevent DNS rebinding attacks\n**Bind to Localhost**: When running locally, bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)\n**Implement Authentication**: Use proper authentication for all connections\n**Use HTTPS**: Always use TLS/HTTPS for production deployments\n**Validate Session IDs**: Ensure session IDs are cryptographically secure and properly validated\n\nWithout these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.\n### Server-Sent Events (SSE) - Deprecated\n\nSSE as a standalone transport is deprecated as of protocol version 2024-11-05.\nIt has been replaced by Streamable HTTP, which incorporates SSE as an optional\nstreaming mechanism. For backwards compatibility information, see the\nbackwards compatibility section below.\nThe legacy SSE transport enabled server-to-client streaming with HTTP POST requests for client-to-server communication.\nPreviously used when:\n- Only server-to-client streaming is needed\n- Working with restricted networks\n- Implementing simple updates\n\n#### Legacy Security Considerations\n\nThe deprecated SSE transport had similar security considerations to Streamable HTTP, particularly regarding DNS rebinding attacks. These same protections should be applied when using SSE streams within the Streamable HTTP transport.\n#### Server\n\n#### Client\n\n## Custom Transports\n\nMCP makes it easy to implement custom transports for specific needs. Any transport implementation just needs to conform to the Transport interface:\nYou can implement custom transports for:\n- Custom network protocols\n- Specialized communication channels\n- Integration with existing systems\n- Performance optimization\n\n## Error Handling\n\nTransport implementations should handle various error scenarios:\n- Connection errors\n- Message parsing errors\n- Protocol errors\n- Network timeouts\n- Resource cleanup\n\nExample error handling:\n## Best Practices\n\nWhen implementing or using MCP transport:\n- Handle connection lifecycle properly\n- Implement proper error handling\n- Clean up resources on connection close\n- Use appropriate timeouts\n- Validate messages before sending\n- Log transport events for debugging\n- Implement reconnection logic when appropriate\n- Handle backpressure in message queues\n- Monitor connection health\n- Implement proper security measures\n\n## Security Considerations\n\nWhen implementing transport:\n### Authentication and Authorization\n\n- Implement proper authentication mechanisms\n- Validate client credentials\n- Use secure token handling\n- Implement authorization checks\n\n### Data Security\n\n- Use TLS for network transport\n- Encrypt sensitive data\n- Validate message integrity\n- Implement message size limits\n- Sanitize input data\n\n### Network Security\n\n- Implement rate limiting\n- Use appropriate timeouts\n- Handle denial of service scenarios\n- Monitor for unusual patterns\n- Implement proper firewall rules\n- For HTTP-based transports (including Streamable HTTP), validate Origin headers to prevent DNS rebinding attacks\n- For local servers, bind only to localhost (127.0.0.1) instead of all interfaces (0.0.0.0)\n\n## Debugging Transport\n\nTips for debugging transport issues:\n- Enable debug logging\n- Monitor message flow\n- Check connection states\n- Validate message formats\n- Test error scenarios\n- Use network analysis tools\n- Implement health checks\n- Monitor resource usage\n- Test edge cases\n- Use proper error tracking\n\n## Backwards Compatibility\n\nTo maintain compatibility between different protocol versions:\n### For Servers Supporting Older Clients\n\nServers wanting to support clients using the deprecated HTTP+SSE transport should:\n- Host both the old SSE and POST endpoints alongside the new MCP endpoint\n- Handle initialization requests on both endpoints\n- Maintain separate handling logic for each transport type\n\n### For Clients Supporting Older Servers\n\nClients wanting to support servers using the deprecated transport should:\n- Accept server URLs that may use either transport\n- Attempt to POST an\n`InitializeRequest`\n\nwith proper `Accept`\n\nheaders:\n- If successful, use Streamable HTTP transport\n- If it fails with 4xx status, fall back to legacy SSE transport\n\n- Issue a GET request expecting an SSE stream with\n`endpoint`\n\nevent for legacy servers\n\nExample compatibility detection:",
    "metadata": {
      "title": "Transports - Model Context Protocol",
      "description": "Learn about MCP's communication mechanisms",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/legacy/concepts/transports",
      "extracted_at": "2025-08-04T09:55:41.135029+00:00"
    },
    "word_count": 1025,
    "char_count": 7373,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:41.135085+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/cancellation",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) supports optional cancellation of in-progress requests\nthrough notification messages. Either side can send a cancellation notification to\nindicate that a previously-issued request should be terminated.\n## Cancellation Flow\n\nWhen a party wants to cancel an in-progress request, it sends a `notifications/cancelled`\n\nnotification containing:\n- The ID of the request to cancel\n- An optional reason string that can be logged or displayed\n\n## Behavior Requirements\n\n- Cancellation notifications\n**MUST** only reference requests that:\n- Were previously issued in the same direction\n- Are believed to still be in-progress\n\n- The\n`initialize`\n\nrequest **MUST NOT** be cancelled by clients\n- Receivers of cancellation notifications\n**SHOULD**:\n- Stop processing the cancelled request\n- Free associated resources\n- Not send a response for the cancelled request\n\n- Receivers\n**MAY** ignore cancellation notifications if:\n- The referenced request is unknown\n- Processing has already completed\n- The request cannot be cancelled\n\n- The sender of the cancellation notification\n**SHOULD** ignore any response to the\nrequest that arrives afterward\n\n## Timing Considerations\n\nDue to network latency, cancellation notifications may arrive after request processing\nhas completed, and potentially after a response has already been sent.\nBoth parties **MUST** handle these race conditions gracefully:\n## Implementation Notes\n\n- Both parties\n**SHOULD** log cancellation reasons for debugging\n- Application UIs\n**SHOULD** indicate when cancellation is requested\n\n## Error Handling\n\nInvalid cancellation notifications **SHOULD** be ignored:\n- Unknown request IDs\n- Already completed requests\n- Malformed notifications\n\nThis maintains the “fire and forget” nature of notifications while allowing for race\nconditions in asynchronous communication.",
    "metadata": {
      "title": "Cancellation - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/cancellation",
      "extracted_at": "2025-08-04T09:55:43.706766+00:00"
    },
    "word_count": 263,
    "char_count": 1888,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:43.706791+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/completion",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for servers to offer\nargument autocompletion suggestions for prompts and resource URIs. This enables rich,\nIDE-like experiences where users receive contextual suggestions while entering argument\nvalues.\n## User Interaction Model\n\nCompletion in MCP is designed to support interactive user experiences similar to IDE code\ncompletion.\nFor example, applications may show completion suggestions in a dropdown or popup menu as\nusers type, with the ability to filter and select from available options.\nHowever, implementations are free to expose completion through any interface pattern that\nsuits their needs—the protocol itself does not mandate any specific user\ninteraction model.\n## Capabilities\n\nServers that support completions **MUST** declare the `completions`\n\ncapability:\n## Protocol Messages\n\n### Requesting Completions\n\nTo get completion suggestions, clients send a `completion/complete`\n\nrequest specifying\nwhat is being completed through a reference type:\n**Request:**\n**Response:**\nFor prompts or URI templates with multiple arguments, clients should include previous completions in the `context.arguments`\n\nobject to provide context for subsequent requests.\n**Request:**\n**Response:**\n### Reference Types\n\nThe protocol supports two types of completion references:\n| Type | Description | Example |\n|---|\n`ref/prompt` | References a prompt by name | `{\"type\": \"ref/prompt\", \"name\": \"code_review\"}` |\n`ref/resource` | References a resource URI | `{\"type\": \"ref/resource\", \"uri\": \"file:///{path}\"}` |\n\n### Completion Results\n\nServers return an array of completion values ranked by relevance, with:\n- Maximum 100 items per response\n- Optional total number of available matches\n- Boolean indicating if additional results exist\n\n## Message Flow\n\n## Data Types\n\n### CompleteRequest\n\n`ref`\n\n: A `PromptReference`\n\nor `ResourceReference`\n\n`argument`\n\n: Object containing:\n`name`\n\n: Argument name\n`value`\n\n: Current value\n\n`context`\n\n: Object containing:\n`arguments`\n\n: A mapping of already-resolved argument names to their values.\n\n\n### CompleteResult\n\n`completion`\n\n: Object containing:\n`values`\n\n: Array of suggestions (max 100)\n`total`\n\n: Optional total matches\n`hasMore`\n\n: Additional results flag\n\n\n## Error Handling\n\nServers **SHOULD** return standard JSON-RPC errors for common failure cases:\n- Method not found:\n`-32601`\n\n(Capability not supported)\n- Invalid prompt name:\n`-32602`\n\n(Invalid params)\n- Missing required arguments:\n`-32602`\n\n(Invalid params)\n- Internal errors:\n`-32603`\n\n(Internal error)\n\n## Implementation Considerations\n\n-\nServers\n**SHOULD**:\n- Return suggestions sorted by relevance\n- Implement fuzzy matching where appropriate\n- Rate limit completion requests\n- Validate all inputs\n\n-\nClients\n**SHOULD**:\n- Debounce rapid completion requests\n- Cache completion results where appropriate\n- Handle missing or partial results gracefully\n\n\n## Security\n\nImplementations **MUST**:\n- Validate all completion inputs\n- Implement appropriate rate limiting\n- Control access to sensitive suggestions\n- Prevent completion-based information disclosure",
    "metadata": {
      "title": "Completion - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/completion",
      "extracted_at": "2025-08-04T09:55:45.213329+00:00"
    },
    "word_count": 426,
    "char_count": 3158,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:45.213363+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/ping",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol includes an optional ping mechanism that allows either party\nto verify that their counterpart is still responsive and the connection is alive.\n## Overview\n\nThe ping functionality is implemented through a simple request/response pattern. Either\nthe client or server can initiate a ping by sending a `ping`\n\nrequest.\nA ping request is a standard JSON-RPC request with no parameters:\n## Behavior Requirements\n\n- The receiver\n**MUST** respond promptly with an empty response:\n\n- If no response is received within a reasonable timeout period, the sender\n**MAY**:\n- Consider the connection stale\n- Terminate the connection\n- Attempt reconnection procedures\n\n\n## Usage Patterns\n\n## Implementation Considerations\n\n- Implementations\n**SHOULD** periodically issue pings to detect connection health\n- The frequency of pings\n**SHOULD** be configurable\n- Timeouts\n**SHOULD** be appropriate for the network environment\n- Excessive pinging\n**SHOULD** be avoided to reduce network overhead\n\n## Error Handling\n\n- Timeouts\n**SHOULD** be treated as connection failures\n- Multiple failed pings\n**MAY** trigger connection reset\n- Implementations\n**SHOULD** log ping failures for diagnostics",
    "metadata": {
      "title": "Ping - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/ping",
      "extracted_at": "2025-08-04T09:55:46.696450+00:00"
    },
    "word_count": 176,
    "char_count": 1231,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:46.696465+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) supports optional progress tracking for long-running\noperations through notification messages. Either side can send progress notifications to\nprovide updates about operation status.\n## Progress Flow\n\nWhen a party wants to *receive* progress updates for a request, it includes a\n`progressToken`\n\nin the request metadata.\n- Progress tokens\n**MUST** be a string or integer value\n- Progress tokens can be chosen by the sender using any means, but\n**MUST** be unique\nacross all active requests.\n\nThe receiver **MAY** then send progress notifications containing:\n- The original progress token\n- The current progress value so far\n- An optional “total” value\n- An optional “message” value\n\n- The\n`progress`\n\nvalue **MUST** increase with each notification, even if the total is\nunknown.\n- The\n`progress`\n\nand the `total`\n\nvalues **MAY** be floating point.\n- The\n`message`\n\nfield **SHOULD** provide relevant human readable progress information.\n\n## Behavior Requirements\n\n-\nProgress notifications\n**MUST** only reference tokens that:\n- Were provided in an active request\n- Are associated with an in-progress operation\n\n-\nReceivers of progress requests\n**MAY**:\n- Choose not to send any progress notifications\n- Send notifications at whatever frequency they deem appropriate\n- Omit the total value if unknown\n\n\n## Implementation Notes\n\n- Senders and receivers\n**SHOULD** track active progress tokens\n- Both parties\n**SHOULD** implement rate limiting to prevent flooding\n- Progress notifications\n**MUST** stop after completion",
    "metadata": {
      "title": "Progress - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress",
      "extracted_at": "2025-08-04T09:55:48.174066+00:00"
    },
    "word_count": 233,
    "char_count": 1582,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:48.174087+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/logging",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) provides a standardized way for servers to send\nstructured log messages to clients. Clients can control logging verbosity by setting\nminimum log levels, with servers sending notifications containing severity levels,\noptional logger names, and arbitrary JSON-serializable data.\n## User Interaction Model\n\nImplementations are free to expose logging through any interface pattern that suits their\nneeds—the protocol itself does not mandate any specific user interaction model.\n## Capabilities\n\nServers that emit log message notifications **MUST** declare the `logging`\n\ncapability:\n## Log Levels\n\nThe protocol follows the standard syslog severity levels specified in\nRFC 5424:\n| Level | Description | Example Use Case |\n|---|\n| debug | Detailed debugging information | Function entry/exit points |\n| info | General informational messages | Operation progress updates |\n| notice | Normal but significant events | Configuration changes |\n| warning | Warning conditions | Deprecated feature usage |\n| error | Error conditions | Operation failures |\n| critical | Critical conditions | System component failures |\n| alert | Action must be taken immediately | Data corruption detected |\n| emergency | System is unusable | Complete system failure |\n\n## Protocol Messages\n\n### Setting Log Level\n\nTo configure the minimum log level, clients **MAY** send a `logging/setLevel`\n\nrequest:\n**Request:**\n### Log Message Notifications\n\nServers send log messages using `notifications/message`\n\nnotifications:\n## Message Flow\n\n## Error Handling\n\nServers **SHOULD** return standard JSON-RPC errors for common failure cases:\n- Invalid log level:\n`-32602`\n\n(Invalid params)\n- Configuration errors:\n`-32603`\n\n(Internal error)\n\n## Implementation Considerations\n\n-\nServers\n**SHOULD**:\n- Rate limit log messages\n- Include relevant context in data field\n- Use consistent logger names\n- Remove sensitive information\n\n-\nClients\n**MAY**:\n- Present log messages in the UI\n- Implement log filtering/search\n- Display severity visually\n- Persist log messages\n\n\n## Security\n\n-\nLog messages\n**MUST NOT** contain:\n- Credentials or secrets\n- Personal identifying information\n- Internal system details that could aid attacks\n\n-\nImplementations\n**SHOULD**:\n- Rate limit messages\n- Validate all data fields\n- Control log access\n- Monitor for sensitive content",
    "metadata": {
      "title": "Logging - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/logging",
      "extracted_at": "2025-08-04T09:55:49.639616+00:00"
    },
    "word_count": 351,
    "char_count": 2384,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:49.639642+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification",
    "content": "The Model Context Protocol uses string-based version identifiers following the format\n`YYYY-MM-DD`\n\n, to indicate the last date backwards incompatible changes were made.\nThe protocol version will *not* be incremented when the\nprotocol is updated, as long as the changes maintain backwards compatibility. This allows\nfor incremental improvements while preserving interoperability.\n\n## Revisions\n\nRevisions may be marked as:\n**Draft**: in-progress specifications, not yet ready for consumption.\n**Current**: the current protocol version, which is ready for use and may continue to\nreceive backwards compatible changes.\n**Final**: past, complete specifications that will not be changed.\n\nThe **current** protocol version is **2025-06-18**.\n## Negotiation\n\nVersion negotiation happens during\ninitialization. Clients and\nservers **MAY** support multiple protocol versions simultaneously, but they **MUST**\nagree on a single version to use for the session.\nThe protocol provides appropriate error handling if version negotiation fails, allowing\nclients to gracefully terminate connections when they cannot find a version compatible\nwith the server.",
    "metadata": {
      "title": "Versioning - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification",
      "extracted_at": "2025-08-04T09:55:51.359264+00:00"
    },
    "word_count": 154,
    "char_count": 1142,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:51.359281+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/architecture/index",
    "content": "The Model Context Protocol (MCP) follows a client-host-server architecture where each\nhost can run multiple client instances. This architecture enables users to integrate AI\ncapabilities across applications while maintaining clear security boundaries and\nisolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused\non context exchange and sampling coordination between clients and servers.\n## Core Components\n\n### Host\n\nThe host process acts as the container and coordinator:\n- Creates and manages multiple client instances\n- Controls client connection permissions and lifecycle\n- Enforces security policies and consent requirements\n- Handles user authorization decisions\n- Coordinates AI/LLM integration and sampling\n- Manages context aggregation across clients\n\n### Clients\n\nEach client is created by the host and maintains an isolated server connection:\n- Establishes one stateful session per server\n- Handles protocol negotiation and capability exchange\n- Routes protocol messages bidirectionally\n- Manages subscriptions and notifications\n- Maintains security boundaries between servers\n\nA host application creates and manages multiple clients, with each client having a 1:1\nrelationship with a particular server.\n### Servers\n\nServers provide specialized context and capabilities:\n- Expose resources, tools and prompts via MCP primitives\n- Operate independently with focused responsibilities\n- Request sampling through client interfaces\n- Must respect security constraints\n- Can be local processes or remote services\n\n## Design Principles\n\nMCP is built on several key design principles that inform its architecture and\nimplementation:\n-\n**Servers should be extremely easy to build**\n- Host applications handle complex orchestration responsibilities\n- Servers focus on specific, well-defined capabilities\n- Simple interfaces minimize implementation overhead\n- Clear separation enables maintainable code\n\n-\n**Servers should be highly composable**\n- Each server provides focused functionality in isolation\n- Multiple servers can be combined seamlessly\n- Shared protocol enables interoperability\n- Modular design supports extensibility\n\n-\n**Servers should not be able to read the whole conversation, nor “see into” other\nservers**\n- Servers receive only necessary contextual information\n- Full conversation history stays with the host\n- Each server connection maintains isolation\n- Cross-server interactions are controlled by the host\n- Host process enforces security boundaries\n\n-\n**Features can be added to servers and clients progressively**\n- Core protocol provides minimal required functionality\n- Additional capabilities can be negotiated as needed\n- Servers and clients evolve independently\n- Protocol designed for future extensibility\n- Backwards compatibility is maintained\n\n\n## Capability Negotiation\n\nThe Model Context Protocol uses a capability-based negotiation system where clients and\nservers explicitly declare their supported features during initialization. Capabilities\ndetermine which protocol features and primitives are available during a session.\n- Servers declare capabilities like resource subscriptions, tool support, and prompt\ntemplates\n- Clients declare capabilities like sampling support and notification handling\n- Both parties must respect declared capabilities throughout the session\n- Additional capabilities can be negotiated through extensions to the protocol\n\nEach capability unlocks specific protocol features for use during the session. For\nexample:\n- Implemented server features must be advertised in the\nserver’s capabilities\n- Emitting resource subscription notifications requires the server to declare\nsubscription support\n- Tool invocation requires the server to declare tool capabilities\n- Sampling requires the client to declare support in its\ncapabilities\n\nThis capability negotiation ensures clients and servers have a clear understanding of\nsupported functionality while maintaining protocol extensibility.",
    "metadata": {
      "title": "Architecture - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/architecture/index",
      "extracted_at": "2025-08-04T09:55:52.963880+00:00"
    },
    "word_count": 541,
    "char_count": 3982,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:52.963913+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2024-11-05/basic/transports",
    "content": "**Protocol Revision**: 2024-11-05\n\nMCP currently defines two standard transport mechanisms for client-server communication:\n- stdio, communication over standard in and standard out\n- HTTP with Server-Sent Events (SSE)\n\nClients **SHOULD** support stdio whenever possible.\nIt is also possible for clients and servers to implement\ncustom transports in a pluggable fashion.\n## stdio\n\nIn the **stdio** transport:\n- The client launches the MCP server as a subprocess.\n- The server receives JSON-RPC messages on its standard input (\n`stdin`\n\n) and writes\nresponses to its standard output (`stdout`\n\n).\n- Messages are delimited by newlines, and\n**MUST NOT** contain embedded newlines.\n- The server\n**MAY** write UTF-8 strings to its standard error (`stderr`\n\n) for logging\npurposes. Clients **MAY** capture, forward, or ignore this logging.\n- The server\n**MUST NOT** write anything to its `stdout`\n\nthat is not a valid MCP message.\n- The client\n**MUST NOT** write anything to the server’s `stdin`\n\nthat is not a valid MCP\nmessage.\n\n## HTTP with SSE\n\nIn the **SSE** transport, the server operates as an independent process that can handle\nmultiple client connections.\n#### Security Warning\n\nWhen implementing HTTP with SSE transport:\n- Servers\n**MUST** validate the `Origin`\n\nheader on all incoming connections to prevent DNS rebinding attacks\n- When running locally, servers\n**SHOULD** bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)\n- Servers\n**SHOULD** implement proper authentication for all connections\n\nWithout these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.\nThe server **MUST** provide two endpoints:\n- An SSE endpoint, for clients to establish a connection and receive messages from the\nserver\n- A regular HTTP POST endpoint for clients to send messages to the server\n\nWhen a client connects, the server **MUST** send an `endpoint`\n\nevent containing a URI for\nthe client to use for sending messages. All subsequent client messages **MUST** be sent\nas HTTP POST requests to this endpoint.\nServer messages are sent as SSE `message`\n\nevents, with the message content encoded as\nJSON in the event data.\n## Custom Transports\n\nClients and servers **MAY** implement additional custom transport mechanisms to suit\ntheir specific needs. The protocol is transport-agnostic and can be implemented over any\ncommunication channel that supports bidirectional message exchange.\nImplementers who choose to support custom transports **MUST** ensure they preserve the\nJSON-RPC message format and lifecycle requirements defined by MCP. Custom transports\n**SHOULD** document their specific connection establishment and message exchange patterns\nto aid interoperability.",
    "metadata": {
      "title": "Transports - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2024-11-05/basic/transports",
      "extracted_at": "2025-08-04T09:55:54.476128+00:00"
    },
    "word_count": 409,
    "char_count": 2742,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:54.476158+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/pagination",
    "content": "**Protocol Revision**: 2025-06-18\n\nThe Model Context Protocol (MCP) supports paginating list operations that may return\nlarge result sets. Pagination allows servers to yield results in smaller chunks rather\nthan all at once.\nPagination is especially important when connecting to external services over the\ninternet, but also useful for local integrations to avoid performance issues with large\ndata sets.\nPagination in MCP uses an opaque cursor-based approach, instead of numbered pages.\n- The\n**cursor** is an opaque string token, representing a position in the result set\n**Page size** is determined by the server, and clients **MUST NOT** assume a fixed page\nsize\n\nPagination starts when the server sends a **response** that includes:\n- The current page of results\n- An optional\n`nextCursor`\n\nfield if more results exist\n\nAfter receiving a cursor, the client can *continue* paginating by issuing a request\nincluding that cursor:\nThe following MCP operations support pagination:\n`resources/list`\n\n- List available resources\n`resources/templates/list`\n\n- List resource templates\n`prompts/list`\n\n- List available prompts\n`tools/list`\n\n- List available tools\n\n## Implementation Guidelines\n\n-\nServers\n**SHOULD**:\n- Provide stable cursors\n- Handle invalid cursors gracefully\n\n-\nClients\n**SHOULD**:\n- Treat a missing\n`nextCursor`\n\nas the end of results\n- Support both paginated and non-paginated flows\n\n-\nClients\n**MUST** treat cursors as opaque tokens:\n- Don’t make assumptions about cursor format\n- Don’t attempt to parse or modify cursors\n- Don’t persist cursors across sessions\n\n\n## Error Handling\n\nInvalid cursors **SHOULD** result in an error with code -32602 (Invalid params).",
    "metadata": {
      "title": "Pagination - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/pagination",
      "extracted_at": "2025-08-04T09:55:55.678679+00:00"
    },
    "word_count": 247,
    "char_count": 1679,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:55.678705+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/2025-03-26",
    "content": "Model Context Protocol (MCP) is an open protocol that\nenables seamless integration between LLM applications and external data sources and\ntools. Whether you’re building an AI-powered IDE, enhancing a chat interface, or creating\ncustom AI workflows, MCP provides a standardized way to connect LLMs with the context\nthey need.\nThis specification defines the authoritative protocol requirements, based on the\nTypeScript schema in\nschema.ts.\nFor implementation guides and examples, visit\nmodelcontextprotocol.io.\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD\nNOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be\ninterpreted as described in BCP 14\n[RFC2119]\n[RFC8174] when, and only when, they\nappear in all capitals, as shown here.\n## Overview\n\nMCP provides a standardized way for applications to:\n- Share contextual information with language models\n- Expose tools and capabilities to AI systems\n- Build composable integrations and workflows\n\nThe protocol uses JSON-RPC 2.0 messages to establish\ncommunication between:\n**Hosts**: LLM applications that initiate connections\n**Clients**: Connectors within the host application\n**Servers**: Services that provide context and capabilities\n\nMCP takes some inspiration from the\nLanguage Server Protocol, which\nstandardizes how to add support for programming languages across a whole ecosystem of\ndevelopment tools. In a similar way, MCP standardizes how to integrate additional context\nand tools into the ecosystem of AI applications.\n## Key Details\n\n### Base Protocol\n\n- JSON-RPC message format\n- Stateful connections\n- Server and client capability negotiation\n\n### Features\n\nServers offer any of the following features to clients:\n**Resources**: Context and data, for the user or the AI model to use\n**Prompts**: Templated messages and workflows for users\n**Tools**: Functions for the AI model to execute\n\nClients may offer the following feature to servers:\n**Sampling**: Server-initiated agentic behaviors and recursive LLM interactions\n\n### Additional Utilities\n\n- Configuration\n- Progress tracking\n- Cancellation\n- Error reporting\n- Logging\n\n## Security and Trust & Safety\n\nThe Model Context Protocol enables powerful capabilities through arbitrary data access\nand code execution paths. With this power comes important security and trust\nconsiderations that all implementors must carefully address.\n### Key Principles\n\n-\n**User Consent and Control**\n- Users must explicitly consent to and understand all data access and operations\n- Users must retain control over what data is shared and what actions are taken\n- Implementors should provide clear UIs for reviewing and authorizing activities\n\n-\n**Data Privacy**\n- Hosts must obtain explicit user consent before exposing user data to servers\n- Hosts must not transmit resource data elsewhere without user consent\n- User data should be protected with appropriate access controls\n\n-\n**Tool Safety**\n- Tools represent arbitrary code execution and must be treated with appropriate\ncaution.\n- In particular, descriptions of tool behavior such as annotations should be\nconsidered untrusted, unless obtained from a trusted server.\n\n- Hosts must obtain explicit user consent before invoking any tool\n- Users should understand what each tool does before authorizing its use\n\n-\n**LLM Sampling Controls**\n- Users must explicitly approve any LLM sampling requests\n- Users should control:\n- Whether sampling occurs at all\n- The actual prompt that will be sent\n- What results the server can see\n\n- The protocol intentionally limits server visibility into prompts\n\n\n### Implementation Guidelines\n\nWhile MCP itself cannot enforce these security principles at the protocol level,\nimplementors **SHOULD**:\n- Build robust consent and authorization flows into their applications\n- Provide clear documentation of security implications\n- Implement appropriate access controls and data protections\n- Follow security best practices in their integrations\n- Consider privacy implications in their feature designs\n\n## Learn More\n\nExplore the detailed specification for each protocol component:",
    "metadata": {
      "title": "Specification - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/2025-03-26",
      "extracted_at": "2025-08-04T09:55:57.145734+00:00"
    },
    "word_count": 603,
    "char_count": 4136,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:57.145772+00:00"
  },
  {
    "url": "https://modelcontextprotocol.io/specification/draft/changelog",
    "content": "This document lists changes made to the Model Context Protocol (MCP) specification since\nthe previous revision, 2025-06-18.\n## Major changes\n\n- Enhance authorization server discovery with support for OpenID Connect Discovery 1.0. (PR #797)\n\n## Other schema changes\n\n## Full changelog\n\nFor a complete list of all changes that have been made since the last protocol revision,\nsee GitHub.",
    "metadata": {
      "title": "Key Changes - Model Context Protocol",
      "description": "",
      "keywords": [],
      "language": "en",
      "last_modified": null,
      "url": "https://modelcontextprotocol.io/specification/draft/changelog",
      "extracted_at": "2025-08-04T09:55:58.570532+00:00"
    },
    "word_count": 59,
    "char_count": 385,
    "crawl_depth": 3,
    "crawled_at": "2025-08-04T09:55:58.570543+00:00"
  }
]